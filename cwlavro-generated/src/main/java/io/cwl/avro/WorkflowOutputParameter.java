/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package io.cwl.avro;

import org.apache.avro.generic.GenericArray;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.util.Utf8;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.SchemaStore;

/** Describe an output parameter of a workflow.  The parameter must be
connected to one or more parameters defined in the workflow that will
provide the value of the output parameter.
 */
@org.apache.avro.specific.AvroGenerated
public class WorkflowOutputParameter extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 1729096481505276493L;


  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"WorkflowOutputParameter\",\"namespace\":\"io.cwl.avro\",\"doc\":\"Describe an output parameter of a workflow.  The parameter must be\\nconnected to one or more parameters defined in the workflow that will\\nprovide the value of the output parameter.\\n\",\"fields\":[{\"name\":\"label\",\"type\":[\"null\",\"string\"],\"doc\":\"A short, human-readable label of this object.\",\"jsonldPredicate\":\"rdfs:label\",\"inherited_from\":\"https://w3id.org/cwl/cwl#SchemaBase\"},{\"name\":\"secondaryFiles\",\"type\":[\"null\",\"string\",{\"type\":\"enum\",\"name\":\"Expression\",\"doc\":\"'Expression' is not a real type.  It indicates that a field must allow\\nruntime parameter references.  If [InlineJavascriptRequirement](#InlineJavascriptRequirement)\\nis declared and supported by the platform, the field must also allow\\nJavascript expressions.\\n\",\"symbols\":[\"ExpressionPlaceholder\"]},{\"type\":\"array\",\"items\":[\"string\",\"Expression\"]}],\"doc\":\"Only valid when `type: File` or is an array of `items: File`.\\n\\nProvides a pattern or expression specifying files or directories that\\nmust be included alongside the primary file.  All listed secondary\\nfiles must be present.  An implementation may fail workflow execution\\nif an expected secondary file does not exist.\\n\\nIf the value is an expression, the value of `self` in the expression\\nmust be the primary input or output File object to which this binding\\napplies.  The `basename`, `nameroot` and `nameext` fields must be\\npresent in `self`.  For `CommandLineTool` outputs the `path` field must\\nalso be present.  The expression must return a filename string relative\\nto the path to the primary File, a File or Directory object with either\\n`path` or `location` and `basename` fields set, or an array consisting\\nof strings or File or Directory objects.  It is legal to reference an\\nunchanged File or Directory object taken from input as a secondaryFile.\\n\\nTo work on non-filename-preserving storage systems, portable tool\\ndescriptions should avoid constructing new values from `location`, but\\nshould construct relative references using `basename` or `nameroot`\\ninstead.\\n\\nIf a value in `secondaryFiles` is a string that is not an expression,\\nit specifies that the following pattern should be applied to the path\\nof the primary file to yield a filename relative to the primary File:\\n\\n  1. If string begins with one or more caret `^` characters, for each\\n    caret, remove the last file extension from the path (the last\\n    period `.` and all following characters).  If there are no file\\n    extensions, the path is unchanged.\\n  2. Append the remainder of the string to the end of the file path.\\n\",\"jsonldPredicate\":\"cwl:secondaryFiles\",\"inherited_from\":\"https://w3id.org/cwl/cwl#Parameter\"},{\"name\":\"streamable\",\"type\":[\"null\",\"boolean\"],\"doc\":\"Only valid when `type: File` or is an array of `items: File`.\\n\\nA value of `true` indicates that the file is read or written\\nsequentially without seeking.  An implementation may use this flag to\\nindicate whether it is valid to stream file contents using a named\\npipe.  Default: `false`.\\n\",\"inherited_from\":\"https://w3id.org/cwl/cwl#Parameter\"},{\"name\":\"doc\",\"type\":[\"null\",\"string\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"A documentation string for this type, or an array of strings which should be concatenated.\",\"jsonldPredicate\":\"rdfs:comment\",\"inherited_from\":\"https://w3id.org/cwl/cwl#Parameter\"},{\"name\":\"id\",\"type\":\"string\",\"doc\":\"The unique identifier for this parameter object.\",\"jsonldPredicate\":\"@id\",\"inherited_from\":\"https://w3id.org/cwl/cwl#OutputParameter\"},{\"name\":\"outputBinding\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"CommandOutputBinding\",\"doc\":\"Describes how to generate an output parameter based on the files produced\\nby a CommandLineTool.\\n\\nThe output parameter value is generated by applying these operations in the\\nfollowing order:\\n\\n  - glob\\n  - loadContents\\n  - outputEval\\n  - secondaryFiles\\n\",\"fields\":[{\"name\":\"glob\",\"type\":[\"null\",\"string\",\"Expression\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"Find files relative to the output directory, using POSIX glob(3)\\npathname matching.  If an array is provided, find files that match any\\npattern in the array.  If an expression is provided, the expression must\\nreturn a string or an array of strings, which will then be evaluated as\\none or more glob patterns.  Must only match and return files which\\nactually exist.\\n\"},{\"name\":\"loadContents\",\"type\":[\"null\",\"boolean\"],\"doc\":\"For each file matched in `glob`, read up to\\nthe first 64 KiB of text from the file and place it in the `contents`\\nfield of the file object for manipulation by `outputEval`.\\n\",\"jsonldPredicate\":\"cwl:loadContents\"},{\"name\":\"outputEval\",\"type\":[\"null\",\"string\",\"Expression\"],\"doc\":\"Evaluate an expression to generate the output value.  If `glob` was\\nspecified, the value of `self` must be an array containing file objects\\nthat were matched.  If no files were matched, `self` must be a zero\\nlength array; if a single file was matched, the value of `self` is an\\narray of a single element.  Additionally, if `loadContents` is `true`,\\nthe File objects must include up to the first 64 KiB of file contents\\nin the `contents` field.\\n\"}],\"extends\":\"https://w3id.org/cwl/cwl#OutputBinding\"}],\"doc\":\"Describes how to handle the outputs of a process.\\n\",\"jsonldPredicate\":\"cwl:outputBinding\",\"inherited_from\":\"https://w3id.org/cwl/cwl#OutputParameter\"},{\"name\":\"format\",\"type\":[\"null\",\"string\",\"Expression\"],\"doc\":\"Only valid when `type: File` or is an array of `items: File`.\\n\\nThis is the file format that will be assigned to\\nthe output parameter.\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/cwl#format\",\"_type\":\"@id\",\"identity\":true},\"inherited_from\":\"https://w3id.org/cwl/cwl#OutputParameter\"},{\"name\":\"outputSource\",\"type\":[\"null\",\"string\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"Specifies one or more workflow parameters that supply the value of to\\nthe output parameter.\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/cwl#outputSource\",\"_type\":\"@id\",\"refScope\":0}},{\"name\":\"linkMerge\",\"type\":[\"null\",{\"type\":\"enum\",\"name\":\"LinkMergeMethod\",\"doc\":\"The input link merge method, described in [WorkflowStepInput](#WorkflowStepInput).\",\"symbols\":[\"merge_nested\",\"merge_flattened\"],\"docParent\":\"https://w3id.org/cwl/cwl#WorkflowStepInput\"}],\"doc\":\"The method to use to merge multiple sources into a single array.\\nIf not specified, the default method is \\\"merge_nested\\\".\\n\",\"jsonldPredicate\":\"cwl:linkMerge\"},{\"name\":\"type\",\"type\":[\"null\",{\"type\":\"enum\",\"name\":\"CWLType\",\"symbols\":[\"null\",\"boolean\",\"int\",\"long\",\"float\",\"double\",\"string\",\"File\",\"Directory\"],\"extends\":\"https://w3id.org/cwl/salad#PrimitiveType\"},{\"type\":\"record\",\"name\":\"OutputRecordSchema\",\"fields\":[{\"name\":\"fields\",\"type\":[\"null\",{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"OutputRecordField\",\"fields\":[{\"name\":\"name\",\"type\":\"string\",\"doc\":\"The name of the field\\n\",\"jsonldPredicate\":\"@id\",\"inherited_from\":\"https://w3id.org/cwl/salad#RecordField\"},{\"name\":\"doc\",\"type\":[\"null\",\"string\"],\"doc\":\"A documentation string for this field\\n\",\"jsonldPredicate\":\"rdfs:comment\",\"inherited_from\":\"https://w3id.org/cwl/salad#RecordField\"},{\"name\":\"type\",\"type\":[\"CWLType\",\"OutputRecordSchema\",{\"type\":\"record\",\"name\":\"OutputEnumSchema\",\"fields\":[{\"name\":\"symbols\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"doc\":\"Defines the set of valid symbols.\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#symbols\",\"_type\":\"@id\",\"identity\":true},\"inherited_from\":\"https://w3id.org/cwl/salad#EnumSchema\"},{\"name\":\"type\",\"type\":{\"type\":\"enum\",\"name\":\"Enum_symbol\",\"namespace\":\"io.cwl.avro.EnumSchemaPackage.type\",\"symbols\":[\"enum\"]},\"doc\":\"Must be `enum`\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#type\",\"_type\":\"@vocab\",\"typeDSL\":true,\"refScope\":2},\"inherited_from\":\"https://w3id.org/cwl/salad#EnumSchema\"},{\"name\":\"label\",\"type\":[\"null\",\"string\"],\"doc\":\"A short, human-readable label of this object.\",\"jsonldPredicate\":\"rdfs:label\",\"inherited_from\":\"https://w3id.org/cwl/cwl#SchemaBase\"},{\"name\":\"outputBinding\",\"type\":[\"null\",\"CommandOutputBinding\"],\"jsonldPredicate\":\"cwl:outputBinding\"}],\"extends\":[\"https://w3id.org/cwl/salad#EnumSchema\",\"https://w3id.org/cwl/cwl#Out","putSchema\"],\"docParent\":\"https://w3id.org/cwl/cwl#OutputParameter\"},{\"type\":\"record\",\"name\":\"OutputArraySchema\",\"fields\":[{\"name\":\"items\",\"type\":[\"CWLType\",\"OutputRecordSchema\",\"OutputEnumSchema\",\"OutputArraySchema\",\"string\",{\"type\":\"array\",\"items\":[\"CWLType\",\"OutputRecordSchema\",\"OutputEnumSchema\",\"OutputArraySchema\",\"string\"]}],\"doc\":\"Defines the type of the array elements.\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#items\",\"_type\":\"@vocab\",\"refScope\":2},\"inherited_from\":\"https://w3id.org/cwl/salad#ArraySchema\"},{\"name\":\"type\",\"type\":{\"type\":\"enum\",\"name\":\"Array_symbol\",\"namespace\":\"io.cwl.avro.ArraySchemaPackage.type\",\"symbols\":[\"array\"]},\"doc\":\"Must be `array`\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#type\",\"_type\":\"@vocab\",\"typeDSL\":true,\"refScope\":2},\"inherited_from\":\"https://w3id.org/cwl/salad#ArraySchema\"},{\"name\":\"label\",\"type\":[\"null\",\"string\"],\"doc\":\"A short, human-readable label of this object.\",\"jsonldPredicate\":\"rdfs:label\",\"inherited_from\":\"https://w3id.org/cwl/cwl#SchemaBase\"},{\"name\":\"outputBinding\",\"type\":[\"null\",\"CommandOutputBinding\"],\"jsonldPredicate\":\"cwl:outputBinding\"}],\"extends\":[\"https://w3id.org/cwl/salad#ArraySchema\",\"https://w3id.org/cwl/cwl#OutputSchema\"],\"docParent\":\"https://w3id.org/cwl/cwl#OutputParameter\",\"specialize\":[{\"specializeFrom\":\"https://w3id.org/cwl/salad#RecordSchema\",\"specializeTo\":\"https://w3id.org/cwl/cwl#OutputRecordSchema\"},{\"specializeFrom\":\"https://w3id.org/cwl/salad#EnumSchema\",\"specializeTo\":\"https://w3id.org/cwl/cwl#OutputEnumSchema\"},{\"specializeFrom\":\"https://w3id.org/cwl/salad#ArraySchema\",\"specializeTo\":\"https://w3id.org/cwl/cwl#OutputArraySchema\"},{\"specializeFrom\":\"https://w3id.org/cwl/salad#PrimitiveType\",\"specializeTo\":\"https://w3id.org/cwl/cwl#CWLType\"}]},\"string\",{\"type\":\"array\",\"items\":[\"CWLType\",\"OutputRecordSchema\",\"OutputEnumSchema\",\"OutputArraySchema\",\"string\"]}],\"doc\":\"The field type\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#type\",\"_type\":\"@vocab\",\"typeDSL\":true,\"refScope\":2},\"inherited_from\":\"https://w3id.org/cwl/salad#RecordField\"},{\"name\":\"outputBinding\",\"type\":[\"null\",\"CommandOutputBinding\"],\"jsonldPredicate\":\"cwl:outputBinding\"}],\"extends\":\"https://w3id.org/cwl/salad#RecordField\",\"specialize\":[{\"specializeFrom\":\"https://w3id.org/cwl/salad#RecordSchema\",\"specializeTo\":\"https://w3id.org/cwl/cwl#OutputRecordSchema\"},{\"specializeFrom\":\"https://w3id.org/cwl/salad#EnumSchema\",\"specializeTo\":\"https://w3id.org/cwl/cwl#OutputEnumSchema\"},{\"specializeFrom\":\"https://w3id.org/cwl/salad#ArraySchema\",\"specializeTo\":\"https://w3id.org/cwl/cwl#OutputArraySchema\"},{\"specializeFrom\":\"https://w3id.org/cwl/salad#PrimitiveType\",\"specializeTo\":\"https://w3id.org/cwl/cwl#CWLType\"}]}}],\"doc\":\"Defines the fields of the record.\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#fields\",\"mapSubject\":\"name\",\"mapPredicate\":\"type\"},\"inherited_from\":\"https://w3id.org/cwl/salad#RecordSchema\"},{\"name\":\"type\",\"type\":{\"type\":\"enum\",\"name\":\"Record_symbol\",\"namespace\":\"io.cwl.avro.RecordSchemaPackage.type\",\"symbols\":[\"record\"]},\"doc\":\"Must be `record`\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#type\",\"_type\":\"@vocab\",\"typeDSL\":true,\"refScope\":2},\"inherited_from\":\"https://w3id.org/cwl/salad#RecordSchema\"},{\"name\":\"label\",\"type\":[\"null\",\"string\"],\"doc\":\"A short, human-readable label of this object.\",\"jsonldPredicate\":\"rdfs:label\",\"inherited_from\":\"https://w3id.org/cwl/cwl#SchemaBase\"}],\"extends\":[\"https://w3id.org/cwl/salad#RecordSchema\",\"https://w3id.org/cwl/cwl#OutputSchema\"],\"docParent\":\"https://w3id.org/cwl/cwl#OutputParameter\",\"specialize\":[{\"specializeFrom\":\"https://w3id.org/cwl/salad#RecordField\",\"specializeTo\":\"https://w3id.org/cwl/cwl#OutputRecordField\"}]},\"OutputEnumSchema\",\"OutputArraySchema\",\"string\",{\"type\":\"array\",\"items\":[\"CWLType\",\"OutputRecordSchema\",\"OutputEnumSchema\",\"OutputArraySchema\",\"string\"]}],\"doc\":\"Specify valid types of data that may be assigned to this parameter.\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/salad#type\",\"_type\":\"@vocab\",\"refScope\":2,\"typeDSL\":true}}],\"extends\":\"https://w3id.org/cwl/cwl#OutputParameter\",\"docParent\":\"https://w3id.org/cwl/cwl#Workflow\"}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }

  private static final SpecificData MODEL$ = new SpecificData();

  private static final BinaryMessageEncoder<WorkflowOutputParameter> ENCODER =
      new BinaryMessageEncoder<>(MODEL$, SCHEMA$);

  private static final BinaryMessageDecoder<WorkflowOutputParameter> DECODER =
      new BinaryMessageDecoder<>(MODEL$, SCHEMA$);

  /**
   * Return the BinaryMessageEncoder instance used by this class.
   * @return the message encoder used by this class
   */
  public static BinaryMessageEncoder<WorkflowOutputParameter> getEncoder() {
    return ENCODER;
  }

  /**
   * Return the BinaryMessageDecoder instance used by this class.
   * @return the message decoder used by this class
   */
  public static BinaryMessageDecoder<WorkflowOutputParameter> getDecoder() {
    return DECODER;
  }

  /**
   * Create a new BinaryMessageDecoder instance for this class that uses the specified {@link SchemaStore}.
   * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
   * @return a BinaryMessageDecoder instance for this class backed by the given SchemaStore
   */
  public static BinaryMessageDecoder<WorkflowOutputParameter> createDecoder(SchemaStore resolver) {
    return new BinaryMessageDecoder<>(MODEL$, SCHEMA$, resolver);
  }

  /**
   * Serializes this WorkflowOutputParameter to a ByteBuffer.
   * @return a buffer holding the serialized data for this instance
   * @throws java.io.IOException if this instance could not be serialized
   */
  public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
    return ENCODER.encode(this);
  }

  /**
   * Deserializes a WorkflowOutputParameter from a ByteBuffer.
   * @param b a byte buffer holding serialized data for an instance of this class
   * @return a WorkflowOutputParameter instance decoded from the given buffer
   * @throws java.io.IOException if the given bytes could not be deserialized into an instance of this class
   */
  public static WorkflowOutputParameter fromByteBuffer(
      java.nio.ByteBuffer b) throws java.io.IOException {
    return DECODER.decode(b);
  }

  /** A short, human-readable label of this object. */
  public java.lang.CharSequence label;
  /** Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.
 */
  public java.lang.Object secondaryFiles;
  /** Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.
 */
  public java.lang.Boolean streamable;
  /** A documentation string for this type, or an array of strings which should be concatenated. */
  public java.lang.Object doc;
  /** The unique identifier for this parameter object. */
  public java.lang.CharSequence id;
  /** Describes how to handle the outputs of a process.
 */
  public io.cwl.avro.CommandOutputBinding outputBinding;
  /** Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.
 */
  public java.lang.Object format;
  /** Specifies one or more workflow parameters that supply the value of to
the output parameter.
 */
  public java.lang.Object outputSource;
  /** The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".
 */
  public io.cwl.avro.LinkMergeMethod linkMerge;
  /** Specify valid types of data that may be assigned to this parameter.
 */
  public java.lang.Object type;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public WorkflowOutputParameter() {}

  /**
   * All-args constructor.
   * @param label A short, human-readable label of this object.
   * @param secondaryFiles Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.

   * @param streamable Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.

   * @param doc A documentation string for this type, or an array of strings which should be concatenated.
   * @param id The unique identifier for this parameter object.
   * @param outputBinding Describes how to handle the outputs of a process.

   * @param format Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.

   * @param outputSource Specifies one or more workflow parameters that supply the value of to
the output parameter.

   * @param linkMerge The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".

   * @param type Specify valid types of data that may be assigned to this parameter.

   */
  public WorkflowOutputParameter(java.lang.CharSequence label, java.lang.Object secondaryFiles, java.lang.Boolean streamable, java.lang.Object doc, java.lang.CharSequence id, io.cwl.avro.CommandOutputBinding outputBinding, java.lang.Object format, java.lang.Object outputSource, io.cwl.avro.LinkMergeMethod linkMerge, java.lang.Object type) {
    this.label = label;
    this.secondaryFiles = secondaryFiles;
    this.streamable = streamable;
    this.doc = doc;
    this.id = id;
    this.outputBinding = outputBinding;
    this.format = format;
    this.outputSource = outputSource;
    this.linkMerge = linkMerge;
    this.type = type;
  }

  @Override
  public org.apache.avro.specific.SpecificData getSpecificData() { return MODEL$; }

  @Override
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }

  // Used by DatumWriter.  Applications should not call.
  @Override
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return label;
    case 1: return secondaryFiles;
    case 2: return streamable;
    case 3: return doc;
    case 4: return id;
    case 5: return outputBinding;
    case 6: return format;
    case 7: return outputSource;
    case 8: return linkMerge;
    case 9: return type;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  // Used by DatumReader.  Applications should not call.
  @Override
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: label = (java.lang.CharSequence)value$; break;
    case 1: secondaryFiles = value$; break;
    case 2: streamable = (java.lang.Boolean)value$; break;
    case 3: doc = value$; break;
    case 4: id = (java.lang.CharSequence)value$; break;
    case 5: outputBinding = (io.cwl.avro.CommandOutputBinding)value$; break;
    case 6: format = value$; break;
    case 7: outputSource = value$; break;
    case 8: linkMerge = (io.cwl.avro.LinkMergeMethod)value$; break;
    case 9: type = value$; break;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  /**
   * Gets the value of the 'label' field.
   * @return A short, human-readable label of this object.
   */
  public java.lang.CharSequence getLabel() {
    return label;
  }


  /**
   * Sets the value of the 'label' field.
   * A short, human-readable label of this object.
   * @param value the value to set.
   */
  public void setLabel(java.lang.CharSequence value) {
    this.label = value;
  }

  /**
   * Gets the value of the 'secondaryFiles' field.
   * @return Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.

   */
  public java.lang.Object getSecondaryFiles() {
    return secondaryFiles;
  }


  /**
   * Sets the value of the 'secondaryFiles' field.
   * Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.

   * @param value the value to set.
   */
  public void setSecondaryFiles(java.lang.Object value) {
    this.secondaryFiles = value;
  }

  /**
   * Gets the value of the 'streamable' field.
   * @return Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.

   */
  public java.lang.Boolean getStreamable() {
    return streamable;
  }


  /**
   * Sets the value of the 'streamable' field.
   * Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.

   * @param value the value to set.
   */
  public void setStreamable(java.lang.Boolean value) {
    this.streamable = value;
  }

  /**
   * Gets the value of the 'doc' field.
   * @return A documentation string for this type, or an array of strings which should be concatenated.
   */
  public java.lang.Object getDoc() {
    return doc;
  }


  /**
   * Sets the value of the 'doc' field.
   * A documentation string for this type, or an array of strings which should be concatenated.
   * @param value the value to set.
   */
  public void setDoc(java.lang.Object value) {
    this.doc = value;
  }

  /**
   * Gets the value of the 'id' field.
   * @return The unique identifier for this parameter object.
   */
  public java.lang.CharSequence getId() {
    return id;
  }


  /**
   * Sets the value of the 'id' field.
   * The unique identifier for this parameter object.
   * @param value the value to set.
   */
  public void setId(java.lang.CharSequence value) {
    this.id = value;
  }

  /**
   * Gets the value of the 'outputBinding' field.
   * @return Describes how to handle the outputs of a process.

   */
  public io.cwl.avro.CommandOutputBinding getOutputBinding() {
    return outputBinding;
  }


  /**
   * Sets the value of the 'outputBinding' field.
   * Describes how to handle the outputs of a process.

   * @param value the value to set.
   */
  public void setOutputBinding(io.cwl.avro.CommandOutputBinding value) {
    this.outputBinding = value;
  }

  /**
   * Gets the value of the 'format' field.
   * @return Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.

   */
  public java.lang.Object getFormat() {
    return format;
  }


  /**
   * Sets the value of the 'format' field.
   * Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.

   * @param value the value to set.
   */
  public void setFormat(java.lang.Object value) {
    this.format = value;
  }

  /**
   * Gets the value of the 'outputSource' field.
   * @return Specifies one or more workflow parameters that supply the value of to
the output parameter.

   */
  public java.lang.Object getOutputSource() {
    return outputSource;
  }


  /**
   * Sets the value of the 'outputSource' field.
   * Specifies one or more workflow parameters that supply the value of to
the output parameter.

   * @param value the value to set.
   */
  public void setOutputSource(java.lang.Object value) {
    this.outputSource = value;
  }

  /**
   * Gets the value of the 'linkMerge' field.
   * @return The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".

   */
  public io.cwl.avro.LinkMergeMethod getLinkMerge() {
    return linkMerge;
  }


  /**
   * Sets the value of the 'linkMerge' field.
   * The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".

   * @param value the value to set.
   */
  public void setLinkMerge(io.cwl.avro.LinkMergeMethod value) {
    this.linkMerge = value;
  }

  /**
   * Gets the value of the 'type' field.
   * @return Specify valid types of data that may be assigned to this parameter.

   */
  public java.lang.Object getType() {
    return type;
  }


  /**
   * Sets the value of the 'type' field.
   * Specify valid types of data that may be assigned to this parameter.

   * @param value the value to set.
   */
  public void setType(java.lang.Object value) {
    this.type = value;
  }

  /**
   * Creates a new WorkflowOutputParameter RecordBuilder.
   * @return A new WorkflowOutputParameter RecordBuilder
   */
  public static io.cwl.avro.WorkflowOutputParameter.Builder newBuilder() {
    return new io.cwl.avro.WorkflowOutputParameter.Builder();
  }

  /**
   * Creates a new WorkflowOutputParameter RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new WorkflowOutputParameter RecordBuilder
   */
  public static io.cwl.avro.WorkflowOutputParameter.Builder newBuilder(io.cwl.avro.WorkflowOutputParameter.Builder other) {
    if (other == null) {
      return new io.cwl.avro.WorkflowOutputParameter.Builder();
    } else {
      return new io.cwl.avro.WorkflowOutputParameter.Builder(other);
    }
  }

  /**
   * Creates a new WorkflowOutputParameter RecordBuilder by copying an existing WorkflowOutputParameter instance.
   * @param other The existing instance to copy.
   * @return A new WorkflowOutputParameter RecordBuilder
   */
  public static io.cwl.avro.WorkflowOutputParameter.Builder newBuilder(io.cwl.avro.WorkflowOutputParameter other) {
    if (other == null) {
      return new io.cwl.avro.WorkflowOutputParameter.Builder();
    } else {
      return new io.cwl.avro.WorkflowOutputParameter.Builder(other);
    }
  }

  /**
   * RecordBuilder for WorkflowOutputParameter instances.
   */
  @org.apache.avro.specific.AvroGenerated
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<WorkflowOutputParameter>
    implements org.apache.avro.data.RecordBuilder<WorkflowOutputParameter> {

    /** A short, human-readable label of this object. */
    private java.lang.CharSequence label;
    /** Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.
 */
    private java.lang.Object secondaryFiles;
    /** Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.
 */
    private java.lang.Boolean streamable;
    /** A documentation string for this type, or an array of strings which should be concatenated. */
    private java.lang.Object doc;
    /** The unique identifier for this parameter object. */
    private java.lang.CharSequence id;
    /** Describes how to handle the outputs of a process.
 */
    private io.cwl.avro.CommandOutputBinding outputBinding;
    private io.cwl.avro.CommandOutputBinding.Builder outputBindingBuilder;
    /** Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.
 */
    private java.lang.Object format;
    /** Specifies one or more workflow parameters that supply the value of to
the output parameter.
 */
    private java.lang.Object outputSource;
    /** The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".
 */
    private io.cwl.avro.LinkMergeMethod linkMerge;
    /** Specify valid types of data that may be assigned to this parameter.
 */
    private java.lang.Object type;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$, MODEL$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(io.cwl.avro.WorkflowOutputParameter.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.label)) {
        this.label = data().deepCopy(fields()[0].schema(), other.label);
        fieldSetFlags()[0] = other.fieldSetFlags()[0];
      }
      if (isValidValue(fields()[1], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[1].schema(), other.secondaryFiles);
        fieldSetFlags()[1] = other.fieldSetFlags()[1];
      }
      if (isValidValue(fields()[2], other.streamable)) {
        this.streamable = data().deepCopy(fields()[2].schema(), other.streamable);
        fieldSetFlags()[2] = other.fieldSetFlags()[2];
      }
      if (isValidValue(fields()[3], other.doc)) {
        this.doc = data().deepCopy(fields()[3].schema(), other.doc);
        fieldSetFlags()[3] = other.fieldSetFlags()[3];
      }
      if (isValidValue(fields()[4], other.id)) {
        this.id = data().deepCopy(fields()[4].schema(), other.id);
        fieldSetFlags()[4] = other.fieldSetFlags()[4];
      }
      if (isValidValue(fields()[5], other.outputBinding)) {
        this.outputBinding = data().deepCopy(fields()[5].schema(), other.outputBinding);
        fieldSetFlags()[5] = other.fieldSetFlags()[5];
      }
      if (other.hasOutputBindingBuilder()) {
        this.outputBindingBuilder = io.cwl.avro.CommandOutputBinding.newBuilder(other.getOutputBindingBuilder());
      }
      if (isValidValue(fields()[6], other.format)) {
        this.format = data().deepCopy(fields()[6].schema(), other.format);
        fieldSetFlags()[6] = other.fieldSetFlags()[6];
      }
      if (isValidValue(fields()[7], other.outputSource)) {
        this.outputSource = data().deepCopy(fields()[7].schema(), other.outputSource);
        fieldSetFlags()[7] = other.fieldSetFlags()[7];
      }
      if (isValidValue(fields()[8], other.linkMerge)) {
        this.linkMerge = data().deepCopy(fields()[8].schema(), other.linkMerge);
        fieldSetFlags()[8] = other.fieldSetFlags()[8];
      }
      if (isValidValue(fields()[9], other.type)) {
        this.type = data().deepCopy(fields()[9].schema(), other.type);
        fieldSetFlags()[9] = other.fieldSetFlags()[9];
      }
    }

    /**
     * Creates a Builder by copying an existing WorkflowOutputParameter instance
     * @param other The existing instance to copy.
     */
    private Builder(io.cwl.avro.WorkflowOutputParameter other) {
      super(SCHEMA$, MODEL$);
      if (isValidValue(fields()[0], other.label)) {
        this.label = data().deepCopy(fields()[0].schema(), other.label);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[1].schema(), other.secondaryFiles);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.streamable)) {
        this.streamable = data().deepCopy(fields()[2].schema(), other.streamable);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.doc)) {
        this.doc = data().deepCopy(fields()[3].schema(), other.doc);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.id)) {
        this.id = data().deepCopy(fields()[4].schema(), other.id);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.outputBinding)) {
        this.outputBinding = data().deepCopy(fields()[5].schema(), other.outputBinding);
        fieldSetFlags()[5] = true;
      }
      this.outputBindingBuilder = null;
      if (isValidValue(fields()[6], other.format)) {
        this.format = data().deepCopy(fields()[6].schema(), other.format);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.outputSource)) {
        this.outputSource = data().deepCopy(fields()[7].schema(), other.outputSource);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.linkMerge)) {
        this.linkMerge = data().deepCopy(fields()[8].schema(), other.linkMerge);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.type)) {
        this.type = data().deepCopy(fields()[9].schema(), other.type);
        fieldSetFlags()[9] = true;
      }
    }

    /**
      * Gets the value of the 'label' field.
      * A short, human-readable label of this object.
      * @return The value.
      */
    public java.lang.CharSequence getLabel() {
      return label;
    }


    /**
      * Sets the value of the 'label' field.
      * A short, human-readable label of this object.
      * @param value The value of 'label'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setLabel(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.label = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'label' field has been set.
      * A short, human-readable label of this object.
      * @return True if the 'label' field has been set, false otherwise.
      */
    public boolean hasLabel() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'label' field.
      * A short, human-readable label of this object.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearLabel() {
      label = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'secondaryFiles' field.
      * Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.

      * @return The value.
      */
    public java.lang.Object getSecondaryFiles() {
      return secondaryFiles;
    }


    /**
      * Sets the value of the 'secondaryFiles' field.
      * Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.

      * @param value The value of 'secondaryFiles'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setSecondaryFiles(java.lang.Object value) {
      validate(fields()[1], value);
      this.secondaryFiles = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'secondaryFiles' field has been set.
      * Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.

      * @return True if the 'secondaryFiles' field has been set, false otherwise.
      */
    public boolean hasSecondaryFiles() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'secondaryFiles' field.
      * Only valid when `type: File` or is an array of `items: File`.

Provides a pattern or expression specifying files or directories that
must be included alongside the primary file.  All listed secondary
files must be present.  An implementation may fail workflow execution
if an expected secondary file does not exist.

If the value is an expression, the value of `self` in the expression
must be the primary input or output File object to which this binding
applies.  The `basename`, `nameroot` and `nameext` fields must be
present in `self`.  For `CommandLineTool` outputs the `path` field must
also be present.  The expression must return a filename string relative
to the path to the primary File, a File or Directory object with either
`path` or `location` and `basename` fields set, or an array consisting
of strings or File or Directory objects.  It is legal to reference an
unchanged File or Directory object taken from input as a secondaryFile.

To work on non-filename-preserving storage systems, portable tool
descriptions should avoid constructing new values from `location`, but
should construct relative references using `basename` or `nameroot`
instead.

If a value in `secondaryFiles` is a string that is not an expression,
it specifies that the following pattern should be applied to the path
of the primary file to yield a filename relative to the primary File:

  1. If string begins with one or more caret `^` characters, for each
    caret, remove the last file extension from the path (the last
    period `.` and all following characters).  If there are no file
    extensions, the path is unchanged.
  2. Append the remainder of the string to the end of the file path.

      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearSecondaryFiles() {
      secondaryFiles = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'streamable' field.
      * Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.

      * @return The value.
      */
    public java.lang.Boolean getStreamable() {
      return streamable;
    }


    /**
      * Sets the value of the 'streamable' field.
      * Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.

      * @param value The value of 'streamable'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setStreamable(java.lang.Boolean value) {
      validate(fields()[2], value);
      this.streamable = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'streamable' field has been set.
      * Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.

      * @return True if the 'streamable' field has been set, false otherwise.
      */
    public boolean hasStreamable() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'streamable' field.
      * Only valid when `type: File` or is an array of `items: File`.

A value of `true` indicates that the file is read or written
sequentially without seeking.  An implementation may use this flag to
indicate whether it is valid to stream file contents using a named
pipe.  Default: `false`.

      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearStreamable() {
      streamable = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'doc' field.
      * A documentation string for this type, or an array of strings which should be concatenated.
      * @return The value.
      */
    public java.lang.Object getDoc() {
      return doc;
    }


    /**
      * Sets the value of the 'doc' field.
      * A documentation string for this type, or an array of strings which should be concatenated.
      * @param value The value of 'doc'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setDoc(java.lang.Object value) {
      validate(fields()[3], value);
      this.doc = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'doc' field has been set.
      * A documentation string for this type, or an array of strings which should be concatenated.
      * @return True if the 'doc' field has been set, false otherwise.
      */
    public boolean hasDoc() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'doc' field.
      * A documentation string for this type, or an array of strings which should be concatenated.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearDoc() {
      doc = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'id' field.
      * The unique identifier for this parameter object.
      * @return The value.
      */
    public java.lang.CharSequence getId() {
      return id;
    }


    /**
      * Sets the value of the 'id' field.
      * The unique identifier for this parameter object.
      * @param value The value of 'id'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setId(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.id = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'id' field has been set.
      * The unique identifier for this parameter object.
      * @return True if the 'id' field has been set, false otherwise.
      */
    public boolean hasId() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'id' field.
      * The unique identifier for this parameter object.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearId() {
      id = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /**
      * Gets the value of the 'outputBinding' field.
      * Describes how to handle the outputs of a process.

      * @return The value.
      */
    public io.cwl.avro.CommandOutputBinding getOutputBinding() {
      return outputBinding;
    }


    /**
      * Sets the value of the 'outputBinding' field.
      * Describes how to handle the outputs of a process.

      * @param value The value of 'outputBinding'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setOutputBinding(io.cwl.avro.CommandOutputBinding value) {
      validate(fields()[5], value);
      this.outputBindingBuilder = null;
      this.outputBinding = value;
      fieldSetFlags()[5] = true;
      return this;
    }

    /**
      * Checks whether the 'outputBinding' field has been set.
      * Describes how to handle the outputs of a process.

      * @return True if the 'outputBinding' field has been set, false otherwise.
      */
    public boolean hasOutputBinding() {
      return fieldSetFlags()[5];
    }

    /**
     * Gets the Builder instance for the 'outputBinding' field and creates one if it doesn't exist yet.
     * Describes how to handle the outputs of a process.

     * @return This builder.
     */
    public io.cwl.avro.CommandOutputBinding.Builder getOutputBindingBuilder() {
      if (outputBindingBuilder == null) {
        if (hasOutputBinding()) {
          setOutputBindingBuilder(io.cwl.avro.CommandOutputBinding.newBuilder(outputBinding));
        } else {
          setOutputBindingBuilder(io.cwl.avro.CommandOutputBinding.newBuilder());
        }
      }
      return outputBindingBuilder;
    }

    /**
     * Sets the Builder instance for the 'outputBinding' field
     * Describes how to handle the outputs of a process.

     * @param value The builder instance that must be set.
     * @return This builder.
     */

    public io.cwl.avro.WorkflowOutputParameter.Builder setOutputBindingBuilder(io.cwl.avro.CommandOutputBinding.Builder value) {
      clearOutputBinding();
      outputBindingBuilder = value;
      return this;
    }

    /**
     * Checks whether the 'outputBinding' field has an active Builder instance
     * Describes how to handle the outputs of a process.

     * @return True if the 'outputBinding' field has an active Builder instance
     */
    public boolean hasOutputBindingBuilder() {
      return outputBindingBuilder != null;
    }

    /**
      * Clears the value of the 'outputBinding' field.
      * Describes how to handle the outputs of a process.

      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearOutputBinding() {
      outputBinding = null;
      outputBindingBuilder = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /**
      * Gets the value of the 'format' field.
      * Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.

      * @return The value.
      */
    public java.lang.Object getFormat() {
      return format;
    }


    /**
      * Sets the value of the 'format' field.
      * Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.

      * @param value The value of 'format'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setFormat(java.lang.Object value) {
      validate(fields()[6], value);
      this.format = value;
      fieldSetFlags()[6] = true;
      return this;
    }

    /**
      * Checks whether the 'format' field has been set.
      * Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.

      * @return True if the 'format' field has been set, false otherwise.
      */
    public boolean hasFormat() {
      return fieldSetFlags()[6];
    }


    /**
      * Clears the value of the 'format' field.
      * Only valid when `type: File` or is an array of `items: File`.

This is the file format that will be assigned to
the output parameter.

      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearFormat() {
      format = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /**
      * Gets the value of the 'outputSource' field.
      * Specifies one or more workflow parameters that supply the value of to
the output parameter.

      * @return The value.
      */
    public java.lang.Object getOutputSource() {
      return outputSource;
    }


    /**
      * Sets the value of the 'outputSource' field.
      * Specifies one or more workflow parameters that supply the value of to
the output parameter.

      * @param value The value of 'outputSource'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setOutputSource(java.lang.Object value) {
      validate(fields()[7], value);
      this.outputSource = value;
      fieldSetFlags()[7] = true;
      return this;
    }

    /**
      * Checks whether the 'outputSource' field has been set.
      * Specifies one or more workflow parameters that supply the value of to
the output parameter.

      * @return True if the 'outputSource' field has been set, false otherwise.
      */
    public boolean hasOutputSource() {
      return fieldSetFlags()[7];
    }


    /**
      * Clears the value of the 'outputSource' field.
      * Specifies one or more workflow parameters that supply the value of to
the output parameter.

      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearOutputSource() {
      outputSource = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /**
      * Gets the value of the 'linkMerge' field.
      * The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".

      * @return The value.
      */
    public io.cwl.avro.LinkMergeMethod getLinkMerge() {
      return linkMerge;
    }


    /**
      * Sets the value of the 'linkMerge' field.
      * The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".

      * @param value The value of 'linkMerge'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setLinkMerge(io.cwl.avro.LinkMergeMethod value) {
      validate(fields()[8], value);
      this.linkMerge = value;
      fieldSetFlags()[8] = true;
      return this;
    }

    /**
      * Checks whether the 'linkMerge' field has been set.
      * The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".

      * @return True if the 'linkMerge' field has been set, false otherwise.
      */
    public boolean hasLinkMerge() {
      return fieldSetFlags()[8];
    }


    /**
      * Clears the value of the 'linkMerge' field.
      * The method to use to merge multiple sources into a single array.
If not specified, the default method is "merge_nested".

      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearLinkMerge() {
      linkMerge = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /**
      * Gets the value of the 'type' field.
      * Specify valid types of data that may be assigned to this parameter.

      * @return The value.
      */
    public java.lang.Object getType() {
      return type;
    }


    /**
      * Sets the value of the 'type' field.
      * Specify valid types of data that may be assigned to this parameter.

      * @param value The value of 'type'.
      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder setType(java.lang.Object value) {
      validate(fields()[9], value);
      this.type = value;
      fieldSetFlags()[9] = true;
      return this;
    }

    /**
      * Checks whether the 'type' field has been set.
      * Specify valid types of data that may be assigned to this parameter.

      * @return True if the 'type' field has been set, false otherwise.
      */
    public boolean hasType() {
      return fieldSetFlags()[9];
    }


    /**
      * Clears the value of the 'type' field.
      * Specify valid types of data that may be assigned to this parameter.

      * @return This builder.
      */
    public io.cwl.avro.WorkflowOutputParameter.Builder clearType() {
      type = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public WorkflowOutputParameter build() {
      try {
        WorkflowOutputParameter record = new WorkflowOutputParameter();
        record.label = fieldSetFlags()[0] ? this.label : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.secondaryFiles = fieldSetFlags()[1] ? this.secondaryFiles :  defaultValue(fields()[1]);
        record.streamable = fieldSetFlags()[2] ? this.streamable : (java.lang.Boolean) defaultValue(fields()[2]);
        record.doc = fieldSetFlags()[3] ? this.doc :  defaultValue(fields()[3]);
        record.id = fieldSetFlags()[4] ? this.id : (java.lang.CharSequence) defaultValue(fields()[4]);
        if (outputBindingBuilder != null) {
          try {
            record.outputBinding = this.outputBindingBuilder.build();
          } catch (org.apache.avro.AvroMissingFieldException e) {
            e.addParentField(record.getSchema().getField("outputBinding"));
            throw e;
          }
        } else {
          record.outputBinding = fieldSetFlags()[5] ? this.outputBinding : (io.cwl.avro.CommandOutputBinding) defaultValue(fields()[5]);
        }
        record.format = fieldSetFlags()[6] ? this.format :  defaultValue(fields()[6]);
        record.outputSource = fieldSetFlags()[7] ? this.outputSource :  defaultValue(fields()[7]);
        record.linkMerge = fieldSetFlags()[8] ? this.linkMerge : (io.cwl.avro.LinkMergeMethod) defaultValue(fields()[8]);
        record.type = fieldSetFlags()[9] ? this.type :  defaultValue(fields()[9]);
        return record;
      } catch (org.apache.avro.AvroMissingFieldException e) {
        throw e;
      } catch (java.lang.Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumWriter<WorkflowOutputParameter>
    WRITER$ = (org.apache.avro.io.DatumWriter<WorkflowOutputParameter>)MODEL$.createDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumReader<WorkflowOutputParameter>
    READER$ = (org.apache.avro.io.DatumReader<WorkflowOutputParameter>)MODEL$.createDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

}










