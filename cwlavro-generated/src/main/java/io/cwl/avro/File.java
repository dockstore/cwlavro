/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package io.cwl.avro;

import org.apache.avro.generic.GenericArray;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.util.Utf8;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.SchemaStore;

/** Represents a file (or group of files when `secondaryFiles` is provided) that
will be accessible by tools using standard POSIX file system call API such as
open(2) and read(2).

Files are represented as objects with `class` of `File`.  File objects have
a number of properties that provide metadata about the file.

The `location` property of a File is a URI that uniquely identifies the
file.  Implementations must support the file:// URI scheme and may support
other schemes such as http://.  The value of `location` may also be a
relative reference, in which case it must be resolved relative to the URI
of the document it appears in.  Alternately to `location`, implementations
must also accept the `path` property on File, which must be a filesystem
path available on the same host as the CWL runner (for inputs) or the
runtime environment of a command line tool execution (for command line tool
outputs).

If no `location` or `path` is specified, a file object must specify
`contents` with the UTF-8 text content of the file.  This is a "file
literal".  File literals do not correspond to external resources, but are
created on disk with `contents` with when needed for a executing a tool.
Where appropriate, expressions can return file literals to define new files
on a runtime.  The maximum size of `contents` is 64 kilobytes.

The `basename` property defines the filename on disk where the file is
staged.  This may differ from the resource name.  If not provided,
`basename` must be computed from the last path part of `location` and made
available to expressions.

The `secondaryFiles` property is a list of File or Directory objects that
must be staged in the same directory as the primary file.  It is an error
for file names to be duplicated in `secondaryFiles`.

The `size` property is the size in bytes of the File.  It must be computed
from the resource and made available to expressions.  The `checksum` field
contains a cryptographic hash of the file content for use it verifying file
contents.  Implementations may, at user option, enable or disable
computation of the `checksum` field for performance or other reasons.
However, the ability to compute output checksums is required to pass the
CWL conformance test suite.

When executing a CommandLineTool, the files and secondary files may be
staged to an arbitrary directory, but must use the value of `basename` for
the filename.  The `path` property must be file path in the context of the
tool execution runtime (local to the compute node, or within the executing
container).  All computed properties should be available to expressions.
File literals also must be staged and `path` must be set.

When collecting CommandLineTool outputs, `glob` matching returns file paths
(with the `path` property) and the derived properties. This can all be
modified by `outputEval`.  Alternately, if the file `cwl.output.json` is
present in the output, `outputBinding` is ignored.

File objects in the output must provide either a `location` URI or a `path`
property in the context of the tool execution runtime (local to the compute
node, or within the executing container).

When evaluating an ExpressionTool, file objects must be referenced via
`location` (the expression tool does not have access to files on disk so
`path` is meaningless) or as file literals.  It is legal to return a file
object with an existing `location` but a different `basename`.  The
`loadContents` field of ExpressionTool inputs behaves the same as on
CommandLineTool inputs, however it is not meaningful on the outputs.

An ExpressionTool may forward file references from input to output by using
the same value for `location`.
 */
@org.apache.avro.specific.AvroGenerated
public class File extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 5908835625715528230L;


  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"File\",\"namespace\":\"io.cwl.avro\",\"doc\":\"Represents a file (or group of files when `secondaryFiles` is provided) that\\nwill be accessible by tools using standard POSIX file system call API such as\\nopen(2) and read(2).\\n\\nFiles are represented as objects with `class` of `File`.  File objects have\\na number of properties that provide metadata about the file.\\n\\nThe `location` property of a File is a URI that uniquely identifies the\\nfile.  Implementations must support the file:// URI scheme and may support\\nother schemes such as http://.  The value of `location` may also be a\\nrelative reference, in which case it must be resolved relative to the URI\\nof the document it appears in.  Alternately to `location`, implementations\\nmust also accept the `path` property on File, which must be a filesystem\\npath available on the same host as the CWL runner (for inputs) or the\\nruntime environment of a command line tool execution (for command line tool\\noutputs).\\n\\nIf no `location` or `path` is specified, a file object must specify\\n`contents` with the UTF-8 text content of the file.  This is a \\\"file\\nliteral\\\".  File literals do not correspond to external resources, but are\\ncreated on disk with `contents` with when needed for a executing a tool.\\nWhere appropriate, expressions can return file literals to define new files\\non a runtime.  The maximum size of `contents` is 64 kilobytes.\\n\\nThe `basename` property defines the filename on disk where the file is\\nstaged.  This may differ from the resource name.  If not provided,\\n`basename` must be computed from the last path part of `location` and made\\navailable to expressions.\\n\\nThe `secondaryFiles` property is a list of File or Directory objects that\\nmust be staged in the same directory as the primary file.  It is an error\\nfor file names to be duplicated in `secondaryFiles`.\\n\\nThe `size` property is the size in bytes of the File.  It must be computed\\nfrom the resource and made available to expressions.  The `checksum` field\\ncontains a cryptographic hash of the file content for use it verifying file\\ncontents.  Implementations may, at user option, enable or disable\\ncomputation of the `checksum` field for performance or other reasons.\\nHowever, the ability to compute output checksums is required to pass the\\nCWL conformance test suite.\\n\\nWhen executing a CommandLineTool, the files and secondary files may be\\nstaged to an arbitrary directory, but must use the value of `basename` for\\nthe filename.  The `path` property must be file path in the context of the\\ntool execution runtime (local to the compute node, or within the executing\\ncontainer).  All computed properties should be available to expressions.\\nFile literals also must be staged and `path` must be set.\\n\\nWhen collecting CommandLineTool outputs, `glob` matching returns file paths\\n(with the `path` property) and the derived properties. This can all be\\nmodified by `outputEval`.  Alternately, if the file `cwl.output.json` is\\npresent in the output, `outputBinding` is ignored.\\n\\nFile objects in the output must provide either a `location` URI or a `path`\\nproperty in the context of the tool execution runtime (local to the compute\\nnode, or within the executing container).\\n\\nWhen evaluating an ExpressionTool, file objects must be referenced via\\n`location` (the expression tool does not have access to files on disk so\\n`path` is meaningless) or as file literals.  It is legal to return a file\\nobject with an existing `location` but a different `basename`.  The\\n`loadContents` field of ExpressionTool inputs behaves the same as on\\nCommandLineTool inputs, however it is not meaningful on the outputs.\\n\\nAn ExpressionTool may forward file references from input to output by using\\nthe same value for `location`.\\n\",\"fields\":[{\"name\":\"class\",\"type\":{\"type\":\"enum\",\"name\":\"File_class\",\"namespace\":\"io.cwl.avro.File.class\",\"symbols\":[\"File\"]},\"doc\":\"Must be `File` to indicate this object describes a file.\",\"jsonldPredicate\":{\"_id\":\"@type\",\"_type\":\"@vocab\"}},{\"name\":\"location\",\"type\":[\"null\",\"string\"],\"doc\":\"An IRI that identifies the file resource.  This may be a relative\\nreference, in which case it must be resolved using the base IRI of the\\ndocument.  The location may refer to a local or remote resource; the\\nimplementation must use the IRI to retrieve file content.  If an\\nimplementation is unable to retrieve the file content stored at a\\nremote resource (due to unsupported protocol, access denied, or other\\nissue) it must signal an error.\\n\\nIf the `location` field is not provided, the `contents` field must be\\nprovided.  The implementation must assign a unique identifier for\\nthe `location` field.\\n\\nIf the `path` field is provided but the `location` field is not, an\\nimplementation may assign the value of the `path` field to `location`,\\nthen follow the rules above.\\n\",\"jsonldPredicate\":{\"_id\":\"@id\",\"_type\":\"@id\"}},{\"name\":\"path\",\"type\":[\"null\",\"string\"],\"doc\":\"The local host path where the File is available when a CommandLineTool is\\nexecuted.  This field must be set by the implementation.  The final\\npath component must match the value of `basename`.  This field\\nmust not be used in any other context.  The command line tool being\\nexecuted must be able to to access the file at `path` using the POSIX\\n`open(2)` syscall.\\n\\nAs a special case, if the `path` field is provided but the `location`\\nfield is not, an implementation may assign the value of the `path`\\nfield to `location`, and remove the `path` field.\\n\\nIf the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)\\n(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\\\\`, `\\\"`, `'`,\\n`<space>`, `<tab>`, and `<newline>`) or characters\\n[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)\\nfor [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)\\nthen implementations may terminate the process with a\\n`permanentFailure`.\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/cwl#path\",\"_type\":\"@id\"}},{\"name\":\"basename\",\"type\":[\"null\",\"string\"],\"doc\":\"The base name of the file, that is, the name of the file without any\\nleading directory path.  The base name must not contain a slash `/`.\\n\\nIf not provided, the implementation must set this field based on the\\n`location` field by taking the final path component after parsing\\n`location` as an IRI.  If `basename` is provided, it is not required to\\nmatch the value from `location`.\\n\\nWhen this file is made available to a CommandLineTool, it must be named\\nwith `basename`, i.e. the final component of the `path` field must match\\n`basename`.\\n\",\"jsonldPredicate\":\"cwl:basename\"},{\"name\":\"dirname\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of the directory containing file, that is, the path leading up\\nto the final slash in the path such that `dirname + '/' + basename ==\\npath`.\\n\\nThe implementation must set this field based on the value of `path`\\nprior to evaluating parameter references or expressions in a\\nCommandLineTool document.  This field must not be used in any other\\ncontext.\\n\"},{\"name\":\"nameroot\",\"type\":[\"null\",\"string\"],\"doc\":\"The basename root such that `nameroot + nameext == basename`, and\\n`nameext` is empty or begins with a period and contains at most one\\nperiod.  For the purposess of path splitting leading periods on the\\nbasename are ignored; a basename of `.cshrc` will have a nameroot of\\n`.cshrc`.\\n\\nThe implementation must set this field automatically based on the value\\nof `basename` prior to evaluating parameter references or expressions.\\n\"},{\"name\":\"nameext\",\"type\":[\"null\",\"string\"],\"doc\":\"The basename extension such that `nameroot + nameext == basename`, and\\n`nameext` is empty or begins with a period and contains at most one\\nperiod.  Leading periods on the basename are ignored; a basename of\\n`.cshrc` will have an empty `nameext`.\\n\\nThe implementation must set this field automatically based on the value\\nof `basename` prior to evaluating parameter references or expressions.\\n\"},{\"name\":\"checksum\",\"type\":[\"null\",\"string\"],\"doc\":\"Optional hash code for validat","ing file integrity.  Currently must be in the form\\n\\\"sha1$ + hexadecimal string\\\" using the SHA-1 algorithm.\\n\"},{\"name\":\"size\",\"type\":[\"null\",\"long\"],\"doc\":\"Optional file size\"},{\"name\":\"secondaryFiles\",\"type\":[\"null\",{\"type\":\"array\",\"items\":[\"File\",{\"type\":\"record\",\"name\":\"Directory\",\"doc\":\"Represents a directory to present to a command line tool.\\n\\nDirectories are represented as objects with `class` of `Directory`.  Directory objects have\\na number of properties that provide metadata about the directory.\\n\\nThe `location` property of a Directory is a URI that uniquely identifies\\nthe directory.  Implementations must support the file:// URI scheme and may\\nsupport other schemes such as http://.  Alternately to `location`,\\nimplementations must also accept the `path` property on Directory, which\\nmust be a filesystem path available on the same host as the CWL runner (for\\ninputs) or the runtime environment of a command line tool execution (for\\ncommand line tool outputs).\\n\\nA Directory object may have a `listing` field.  This is a list of File and\\nDirectory objects that are contained in the Directory.  For each entry in\\n`listing`, the `basename` property defines the name of the File or\\nSubdirectory when staged to disk.  If `listing` is not provided, the\\nimplementation must have some way of fetching the Directory listing at\\nruntime based on the `location` field.\\n\\nIf a Directory does not have `location`, it is a Directory literal.  A\\nDirectory literal must provide `listing`.  Directory literals must be\\ncreated on disk at runtime as needed.\\n\\nThe resources in a Directory literal do not need to have any implied\\nrelationship in their `location`.  For example, a Directory listing may\\ncontain two files located on different hosts.  It is the responsibility of\\nthe runtime to ensure that those files are staged to disk appropriately.\\nSecondary files associated with files in `listing` must also be staged to\\nthe same Directory.\\n\\nWhen executing a CommandLineTool, Directories must be recursively staged\\nfirst and have local values of `path` assigend.\\n\\nDirectory objects in CommandLineTool output must provide either a\\n`location` URI or a `path` property in the context of the tool execution\\nruntime (local to the compute node, or within the executing container).\\n\\nAn ExpressionTool may forward file references from input to output by using\\nthe same value for `location`.\\n\\nName conflicts (the same `basename` appearing multiple times in `listing`\\nor in any entry in `secondaryFiles` in the listing) is a fatal error.\\n\",\"fields\":[{\"name\":\"class\",\"type\":{\"type\":\"enum\",\"name\":\"Directory_class\",\"namespace\":\"io.cwl.avro.Directory.class\",\"symbols\":[\"Directory\"]},\"doc\":\"Must be `Directory` to indicate this object describes a Directory.\",\"jsonldPredicate\":{\"_id\":\"@type\",\"_type\":\"@vocab\"}},{\"name\":\"location\",\"type\":[\"null\",\"string\"],\"doc\":\"An IRI that identifies the directory resource.  This may be a relative\\nreference, in which case it must be resolved using the base IRI of the\\ndocument.  The location may refer to a local or remote resource.  If\\nthe `listing` field is not set, the implementation must use the\\nlocation IRI to retrieve directory listing.  If an implementation is\\nunable to retrieve the directory listing stored at a remote resource (due to\\nunsupported protocol, access denied, or other issue) it must signal an\\nerror.\\n\\nIf the `location` field is not provided, the `listing` field must be\\nprovided.  The implementation must assign a unique identifier for\\nthe `location` field.\\n\\nIf the `path` field is provided but the `location` field is not, an\\nimplementation may assign the value of the `path` field to `location`,\\nthen follow the rules above.\\n\",\"jsonldPredicate\":{\"_id\":\"@id\",\"_type\":\"@id\"}},{\"name\":\"path\",\"type\":[\"null\",\"string\"],\"doc\":\"The local path where the Directory is made available prior to executing a\\nCommandLineTool.  This must be set by the implementation.  This field\\nmust not be used in any other context.  The command line tool being\\nexecuted must be able to to access the directory at `path` using the POSIX\\n`opendir(2)` syscall.\\n\\nIf the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)\\n(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\\\\`, `\\\"`, `'`,\\n`<space>`, `<tab>`, and `<newline>`) or characters\\n[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)\\nfor [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)\\nthen implementations may terminate the process with a\\n`permanentFailure`.\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/cwl#path\",\"_type\":\"@id\"}},{\"name\":\"basename\",\"type\":[\"null\",\"string\"],\"doc\":\"The base name of the directory, that is, the name of the file without any\\nleading directory path.  The base name must not contain a slash `/`.\\n\\nIf not provided, the implementation must set this field based on the\\n`location` field by taking the final path component after parsing\\n`location` as an IRI.  If `basename` is provided, it is not required to\\nmatch the value from `location`.\\n\\nWhen this file is made available to a CommandLineTool, it must be named\\nwith `basename`, i.e. the final component of the `path` field must match\\n`basename`.\\n\",\"jsonldPredicate\":\"cwl:basename\"},{\"name\":\"listing\",\"type\":[\"null\",{\"type\":\"array\",\"items\":[\"File\",\"Directory\"]}],\"doc\":\"List of files or subdirectories contained in this directory.  The name\\nof each file or subdirectory is determined by the `basename` field of\\neach `File` or `Directory` object.  It is an error if a `File` shares a\\n`basename` with any other entry in `listing`.  If two or more\\n`Directory` object share the same `basename`, this must be treated as\\nequivalent to a single subdirectory with the listings recursively\\nmerged.\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/cwl#listing\"}}],\"docAfter\":\"https://w3id.org/cwl/cwl#File\"}]}],\"doc\":\"A list of additional files or directories that are associated with the\\nprimary file and must be transferred alongside the primary file.\\nExamples include indexes of the primary file, or external references\\nwhich must be included when loading primary document.  A file object\\nlisted in `secondaryFiles` may itself include `secondaryFiles` for\\nwhich the same rules apply.\\n\",\"jsonldPredicate\":\"cwl:secondaryFiles\"},{\"name\":\"format\",\"type\":[\"null\",\"string\"],\"doc\":\"The format of the file: this must be an IRI of a concept node that\\nrepresents the file format, preferrably defined within an ontology.\\nIf no ontology is available, file formats may be tested by exact match.\\n\\nReasoning about format compatability must be done by checking that an\\ninput file format is the same, `owl:equivalentClass` or\\n`rdfs:subClassOf` the format required by the input parameter.\\n`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if\\n`B owl:equivalentClass C` and `B owl:subclassOf A` then infer\\n`C owl:subclassOf A`.\\n\\nFile format ontologies may be provided in the \\\"$schemas\\\" metadata at the\\nroot of the document.  If no ontologies are specified in `$schemas`, the\\nruntime may perform exact file format matches.\\n\",\"jsonldPredicate\":{\"_id\":\"https://w3id.org/cwl/cwl#format\",\"_type\":\"@id\",\"identity\":true}},{\"name\":\"contents\",\"type\":[\"null\",\"string\"],\"doc\":\"File contents literal.  Maximum of 64 KiB.\\n\\nIf neither `location` nor `path` is provided, `contents` must be\\nnon-null.  The implementation must assign a unique identifier for the\\n`location` field.  When the file is staged as input to CommandLineTool,\\nthe value of `contents` must be written to a file.\\n\\nIf `loadContents` of `inputBinding` or `outputBinding` is true and\\n`location` is valid, the implementation must read up to the first 64\\nKiB of text from the file and place it in the \\\"contents\\\" field.\\n\"}],\"docParent\":\"https://w3id.org/cwl/cwl#CWLType\"}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }

  private static final SpecificData MODEL$ = new SpecificData();

  private static final BinaryMessageEncoder<File> ENCODER =
      new BinaryMessageEncoder<>(MODEL$, SCHEMA$);

  private static final BinaryMessageDecoder<File> DECODER =
      new BinaryMessageDecoder<>(MODEL$, SCHEMA$);

  /**
   * Return the BinaryMessageEncoder instance used by this class.
   * @return the message encoder used by this class
   */
  public static BinaryMessageEncoder<File> getEncoder() {
    return ENCODER;
  }

  /**
   * Return the BinaryMessageDecoder instance used by this class.
   * @return the message decoder used by this class
   */
  public static BinaryMessageDecoder<File> getDecoder() {
    return DECODER;
  }

  /**
   * Create a new BinaryMessageDecoder instance for this class that uses the specified {@link SchemaStore}.
   * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
   * @return a BinaryMessageDecoder instance for this class backed by the given SchemaStore
   */
  public static BinaryMessageDecoder<File> createDecoder(SchemaStore resolver) {
    return new BinaryMessageDecoder<>(MODEL$, SCHEMA$, resolver);
  }

  /**
   * Serializes this File to a ByteBuffer.
   * @return a buffer holding the serialized data for this instance
   * @throws java.io.IOException if this instance could not be serialized
   */
  public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
    return ENCODER.encode(this);
  }

  /**
   * Deserializes a File from a ByteBuffer.
   * @param b a byte buffer holding serialized data for an instance of this class
   * @return a File instance decoded from the given buffer
   * @throws java.io.IOException if the given bytes could not be deserialized into an instance of this class
   */
  public static File fromByteBuffer(
      java.nio.ByteBuffer b) throws java.io.IOException {
    return DECODER.decode(b);
  }

  /** Must be `File` to indicate this object describes a file. */
  public io.cwl.avro.FilePackage.class$.File_class class$;
  /** An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.
 */
  public java.lang.CharSequence location;
  /** The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.
 */
  public java.lang.CharSequence path;
  /** The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.
 */
  public java.lang.CharSequence basename;
  /** The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.
 */
  public java.lang.CharSequence dirname;
  /** The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.
 */
  public java.lang.CharSequence nameroot;
  /** The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.
 */
  public java.lang.CharSequence nameext;
  /** Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.
 */
  public java.lang.CharSequence checksum;
  /** Optional file size */
  public java.lang.Long size;
  /** A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.
 */
  public java.util.List<java.lang.Object> secondaryFiles;
  /** The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.
 */
  public java.lang.CharSequence format;
  /** File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.
 */
  public java.lang.CharSequence contents;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public File() {}

  /**
   * All-args constructor.
   * @param class$ Must be `File` to indicate this object describes a file.
   * @param location An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.

   * @param path The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.

   * @param basename The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.

   * @param dirname The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.

   * @param nameroot The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

   * @param nameext The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

   * @param checksum Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.

   * @param size Optional file size
   * @param secondaryFiles A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.

   * @param format The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.

   * @param contents File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.

   */
  public File(io.cwl.avro.FilePackage.class$.File_class class$, java.lang.CharSequence location, java.lang.CharSequence path, java.lang.CharSequence basename, java.lang.CharSequence dirname, java.lang.CharSequence nameroot, java.lang.CharSequence nameext, java.lang.CharSequence checksum, java.lang.Long size, java.util.List<java.lang.Object> secondaryFiles, java.lang.CharSequence format, java.lang.CharSequence contents) {
    this.class$ = class$;
    this.location = location;
    this.path = path;
    this.basename = basename;
    this.dirname = dirname;
    this.nameroot = nameroot;
    this.nameext = nameext;
    this.checksum = checksum;
    this.size = size;
    this.secondaryFiles = secondaryFiles;
    this.format = format;
    this.contents = contents;
  }

  @Override
  public org.apache.avro.specific.SpecificData getSpecificData() { return MODEL$; }

  @Override
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }

  // Used by DatumWriter.  Applications should not call.
  @Override
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return class$;
    case 1: return location;
    case 2: return path;
    case 3: return basename;
    case 4: return dirname;
    case 5: return nameroot;
    case 6: return nameext;
    case 7: return checksum;
    case 8: return size;
    case 9: return secondaryFiles;
    case 10: return format;
    case 11: return contents;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  // Used by DatumReader.  Applications should not call.
  @Override
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: class$ = (io.cwl.avro.FilePackage.class$.File_class)value$; break;
    case 1: location = (java.lang.CharSequence)value$; break;
    case 2: path = (java.lang.CharSequence)value$; break;
    case 3: basename = (java.lang.CharSequence)value$; break;
    case 4: dirname = (java.lang.CharSequence)value$; break;
    case 5: nameroot = (java.lang.CharSequence)value$; break;
    case 6: nameext = (java.lang.CharSequence)value$; break;
    case 7: checksum = (java.lang.CharSequence)value$; break;
    case 8: size = (java.lang.Long)value$; break;
    case 9: secondaryFiles = (java.util.List<java.lang.Object>)value$; break;
    case 10: format = (java.lang.CharSequence)value$; break;
    case 11: contents = (java.lang.CharSequence)value$; break;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  /**
   * Gets the value of the 'class$' field.
   * @return Must be `File` to indicate this object describes a file.
   */
  public io.cwl.avro.FilePackage.class$.File_class getClass$() {
    return class$;
  }


  /**
   * Sets the value of the 'class$' field.
   * Must be `File` to indicate this object describes a file.
   * @param value the value to set.
   */
  public void setClass$(io.cwl.avro.FilePackage.class$.File_class value) {
    this.class$ = value;
  }

  /**
   * Gets the value of the 'location' field.
   * @return An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.

   */
  public java.lang.CharSequence getLocation() {
    return location;
  }


  /**
   * Sets the value of the 'location' field.
   * An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.

   * @param value the value to set.
   */
  public void setLocation(java.lang.CharSequence value) {
    this.location = value;
  }

  /**
   * Gets the value of the 'path' field.
   * @return The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.

   */
  public java.lang.CharSequence getPath() {
    return path;
  }


  /**
   * Sets the value of the 'path' field.
   * The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.

   * @param value the value to set.
   */
  public void setPath(java.lang.CharSequence value) {
    this.path = value;
  }

  /**
   * Gets the value of the 'basename' field.
   * @return The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.

   */
  public java.lang.CharSequence getBasename() {
    return basename;
  }


  /**
   * Sets the value of the 'basename' field.
   * The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.

   * @param value the value to set.
   */
  public void setBasename(java.lang.CharSequence value) {
    this.basename = value;
  }

  /**
   * Gets the value of the 'dirname' field.
   * @return The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.

   */
  public java.lang.CharSequence getDirname() {
    return dirname;
  }


  /**
   * Sets the value of the 'dirname' field.
   * The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.

   * @param value the value to set.
   */
  public void setDirname(java.lang.CharSequence value) {
    this.dirname = value;
  }

  /**
   * Gets the value of the 'nameroot' field.
   * @return The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

   */
  public java.lang.CharSequence getNameroot() {
    return nameroot;
  }


  /**
   * Sets the value of the 'nameroot' field.
   * The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

   * @param value the value to set.
   */
  public void setNameroot(java.lang.CharSequence value) {
    this.nameroot = value;
  }

  /**
   * Gets the value of the 'nameext' field.
   * @return The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

   */
  public java.lang.CharSequence getNameext() {
    return nameext;
  }


  /**
   * Sets the value of the 'nameext' field.
   * The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

   * @param value the value to set.
   */
  public void setNameext(java.lang.CharSequence value) {
    this.nameext = value;
  }

  /**
   * Gets the value of the 'checksum' field.
   * @return Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.

   */
  public java.lang.CharSequence getChecksum() {
    return checksum;
  }


  /**
   * Sets the value of the 'checksum' field.
   * Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.

   * @param value the value to set.
   */
  public void setChecksum(java.lang.CharSequence value) {
    this.checksum = value;
  }

  /**
   * Gets the value of the 'size' field.
   * @return Optional file size
   */
  public java.lang.Long getSize() {
    return size;
  }


  /**
   * Sets the value of the 'size' field.
   * Optional file size
   * @param value the value to set.
   */
  public void setSize(java.lang.Long value) {
    this.size = value;
  }

  /**
   * Gets the value of the 'secondaryFiles' field.
   * @return A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.

   */
  public java.util.List<java.lang.Object> getSecondaryFiles() {
    return secondaryFiles;
  }


  /**
   * Sets the value of the 'secondaryFiles' field.
   * A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.

   * @param value the value to set.
   */
  public void setSecondaryFiles(java.util.List<java.lang.Object> value) {
    this.secondaryFiles = value;
  }

  /**
   * Gets the value of the 'format' field.
   * @return The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.

   */
  public java.lang.CharSequence getFormat() {
    return format;
  }


  /**
   * Sets the value of the 'format' field.
   * The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.

   * @param value the value to set.
   */
  public void setFormat(java.lang.CharSequence value) {
    this.format = value;
  }

  /**
   * Gets the value of the 'contents' field.
   * @return File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.

   */
  public java.lang.CharSequence getContents() {
    return contents;
  }


  /**
   * Sets the value of the 'contents' field.
   * File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.

   * @param value the value to set.
   */
  public void setContents(java.lang.CharSequence value) {
    this.contents = value;
  }

  /**
   * Creates a new File RecordBuilder.
   * @return A new File RecordBuilder
   */
  public static io.cwl.avro.File.Builder newBuilder() {
    return new io.cwl.avro.File.Builder();
  }

  /**
   * Creates a new File RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new File RecordBuilder
   */
  public static io.cwl.avro.File.Builder newBuilder(io.cwl.avro.File.Builder other) {
    if (other == null) {
      return new io.cwl.avro.File.Builder();
    } else {
      return new io.cwl.avro.File.Builder(other);
    }
  }

  /**
   * Creates a new File RecordBuilder by copying an existing File instance.
   * @param other The existing instance to copy.
   * @return A new File RecordBuilder
   */
  public static io.cwl.avro.File.Builder newBuilder(io.cwl.avro.File other) {
    if (other == null) {
      return new io.cwl.avro.File.Builder();
    } else {
      return new io.cwl.avro.File.Builder(other);
    }
  }

  /**
   * RecordBuilder for File instances.
   */
  @org.apache.avro.specific.AvroGenerated
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<File>
    implements org.apache.avro.data.RecordBuilder<File> {

    /** Must be `File` to indicate this object describes a file. */
    private io.cwl.avro.FilePackage.class$.File_class class$;
    /** An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.
 */
    private java.lang.CharSequence location;
    /** The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.
 */
    private java.lang.CharSequence path;
    /** The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.
 */
    private java.lang.CharSequence basename;
    /** The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.
 */
    private java.lang.CharSequence dirname;
    /** The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.
 */
    private java.lang.CharSequence nameroot;
    /** The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.
 */
    private java.lang.CharSequence nameext;
    /** Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.
 */
    private java.lang.CharSequence checksum;
    /** Optional file size */
    private java.lang.Long size;
    /** A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.
 */
    private java.util.List<java.lang.Object> secondaryFiles;
    /** The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.
 */
    private java.lang.CharSequence format;
    /** File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.
 */
    private java.lang.CharSequence contents;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$, MODEL$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(io.cwl.avro.File.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.class$)) {
        this.class$ = data().deepCopy(fields()[0].schema(), other.class$);
        fieldSetFlags()[0] = other.fieldSetFlags()[0];
      }
      if (isValidValue(fields()[1], other.location)) {
        this.location = data().deepCopy(fields()[1].schema(), other.location);
        fieldSetFlags()[1] = other.fieldSetFlags()[1];
      }
      if (isValidValue(fields()[2], other.path)) {
        this.path = data().deepCopy(fields()[2].schema(), other.path);
        fieldSetFlags()[2] = other.fieldSetFlags()[2];
      }
      if (isValidValue(fields()[3], other.basename)) {
        this.basename = data().deepCopy(fields()[3].schema(), other.basename);
        fieldSetFlags()[3] = other.fieldSetFlags()[3];
      }
      if (isValidValue(fields()[4], other.dirname)) {
        this.dirname = data().deepCopy(fields()[4].schema(), other.dirname);
        fieldSetFlags()[4] = other.fieldSetFlags()[4];
      }
      if (isValidValue(fields()[5], other.nameroot)) {
        this.nameroot = data().deepCopy(fields()[5].schema(), other.nameroot);
        fieldSetFlags()[5] = other.fieldSetFlags()[5];
      }
      if (isValidValue(fields()[6], other.nameext)) {
        this.nameext = data().deepCopy(fields()[6].schema(), other.nameext);
        fieldSetFlags()[6] = other.fieldSetFlags()[6];
      }
      if (isValidValue(fields()[7], other.checksum)) {
        this.checksum = data().deepCopy(fields()[7].schema(), other.checksum);
        fieldSetFlags()[7] = other.fieldSetFlags()[7];
      }
      if (isValidValue(fields()[8], other.size)) {
        this.size = data().deepCopy(fields()[8].schema(), other.size);
        fieldSetFlags()[8] = other.fieldSetFlags()[8];
      }
      if (isValidValue(fields()[9], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[9].schema(), other.secondaryFiles);
        fieldSetFlags()[9] = other.fieldSetFlags()[9];
      }
      if (isValidValue(fields()[10], other.format)) {
        this.format = data().deepCopy(fields()[10].schema(), other.format);
        fieldSetFlags()[10] = other.fieldSetFlags()[10];
      }
      if (isValidValue(fields()[11], other.contents)) {
        this.contents = data().deepCopy(fields()[11].schema(), other.contents);
        fieldSetFlags()[11] = other.fieldSetFlags()[11];
      }
    }

    /**
     * Creates a Builder by copying an existing File instance
     * @param other The existing instance to copy.
     */
    private Builder(io.cwl.avro.File other) {
      super(SCHEMA$, MODEL$);
      if (isValidValue(fields()[0], other.class$)) {
        this.class$ = data().deepCopy(fields()[0].schema(), other.class$);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.location)) {
        this.location = data().deepCopy(fields()[1].schema(), other.location);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.path)) {
        this.path = data().deepCopy(fields()[2].schema(), other.path);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.basename)) {
        this.basename = data().deepCopy(fields()[3].schema(), other.basename);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.dirname)) {
        this.dirname = data().deepCopy(fields()[4].schema(), other.dirname);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.nameroot)) {
        this.nameroot = data().deepCopy(fields()[5].schema(), other.nameroot);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.nameext)) {
        this.nameext = data().deepCopy(fields()[6].schema(), other.nameext);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.checksum)) {
        this.checksum = data().deepCopy(fields()[7].schema(), other.checksum);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.size)) {
        this.size = data().deepCopy(fields()[8].schema(), other.size);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.secondaryFiles)) {
        this.secondaryFiles = data().deepCopy(fields()[9].schema(), other.secondaryFiles);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.format)) {
        this.format = data().deepCopy(fields()[10].schema(), other.format);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.contents)) {
        this.contents = data().deepCopy(fields()[11].schema(), other.contents);
        fieldSetFlags()[11] = true;
      }
    }

    /**
      * Gets the value of the 'class$' field.
      * Must be `File` to indicate this object describes a file.
      * @return The value.
      */
    public io.cwl.avro.FilePackage.class$.File_class getClass$() {
      return class$;
    }


    /**
      * Sets the value of the 'class$' field.
      * Must be `File` to indicate this object describes a file.
      * @param value The value of 'class$'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setClass$(io.cwl.avro.FilePackage.class$.File_class value) {
      validate(fields()[0], value);
      this.class$ = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'class$' field has been set.
      * Must be `File` to indicate this object describes a file.
      * @return True if the 'class$' field has been set, false otherwise.
      */
    public boolean hasClass$() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'class$' field.
      * Must be `File` to indicate this object describes a file.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearClass$() {
      class$ = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'location' field.
      * An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.

      * @return The value.
      */
    public java.lang.CharSequence getLocation() {
      return location;
    }


    /**
      * Sets the value of the 'location' field.
      * An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.

      * @param value The value of 'location'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setLocation(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.location = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'location' field has been set.
      * An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.

      * @return True if the 'location' field has been set, false otherwise.
      */
    public boolean hasLocation() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'location' field.
      * An IRI that identifies the file resource.  This may be a relative
reference, in which case it must be resolved using the base IRI of the
document.  The location may refer to a local or remote resource; the
implementation must use the IRI to retrieve file content.  If an
implementation is unable to retrieve the file content stored at a
remote resource (due to unsupported protocol, access denied, or other
issue) it must signal an error.

If the `location` field is not provided, the `contents` field must be
provided.  The implementation must assign a unique identifier for
the `location` field.

If the `path` field is provided but the `location` field is not, an
implementation may assign the value of the `path` field to `location`,
then follow the rules above.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearLocation() {
      location = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'path' field.
      * The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.

      * @return The value.
      */
    public java.lang.CharSequence getPath() {
      return path;
    }


    /**
      * Sets the value of the 'path' field.
      * The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.

      * @param value The value of 'path'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setPath(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.path = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'path' field has been set.
      * The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.

      * @return True if the 'path' field has been set, false otherwise.
      */
    public boolean hasPath() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'path' field.
      * The local host path where the File is available when a CommandLineTool is
executed.  This field must be set by the implementation.  The final
path component must match the value of `basename`.  This field
must not be used in any other context.  The command line tool being
executed must be able to to access the file at `path` using the POSIX
`open(2)` syscall.

As a special case, if the `path` field is provided but the `location`
field is not, an implementation may assign the value of the `path`
field to `location`, and remove the `path` field.

If the `path` contains [POSIX shell metacharacters](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02)
(`|`,`&`, `;`, `<`, `>`, `(`,`)`, `$`,`` ` ``, `\`, `"`, `'`,
`<space>`, `<tab>`, and `<newline>`) or characters
[not allowed](http://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml)
for [Internationalized Domain Names for Applications](https://tools.ietf.org/html/rfc6452)
then implementations may terminate the process with a
`permanentFailure`.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearPath() {
      path = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'basename' field.
      * The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.

      * @return The value.
      */
    public java.lang.CharSequence getBasename() {
      return basename;
    }


    /**
      * Sets the value of the 'basename' field.
      * The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.

      * @param value The value of 'basename'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setBasename(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.basename = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'basename' field has been set.
      * The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.

      * @return True if the 'basename' field has been set, false otherwise.
      */
    public boolean hasBasename() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'basename' field.
      * The base name of the file, that is, the name of the file without any
leading directory path.  The base name must not contain a slash `/`.

If not provided, the implementation must set this field based on the
`location` field by taking the final path component after parsing
`location` as an IRI.  If `basename` is provided, it is not required to
match the value from `location`.

When this file is made available to a CommandLineTool, it must be named
with `basename`, i.e. the final component of the `path` field must match
`basename`.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearBasename() {
      basename = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'dirname' field.
      * The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.

      * @return The value.
      */
    public java.lang.CharSequence getDirname() {
      return dirname;
    }


    /**
      * Sets the value of the 'dirname' field.
      * The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.

      * @param value The value of 'dirname'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setDirname(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.dirname = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'dirname' field has been set.
      * The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.

      * @return True if the 'dirname' field has been set, false otherwise.
      */
    public boolean hasDirname() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'dirname' field.
      * The name of the directory containing file, that is, the path leading up
to the final slash in the path such that `dirname + '/' + basename ==
path`.

The implementation must set this field based on the value of `path`
prior to evaluating parameter references or expressions in a
CommandLineTool document.  This field must not be used in any other
context.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearDirname() {
      dirname = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /**
      * Gets the value of the 'nameroot' field.
      * The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @return The value.
      */
    public java.lang.CharSequence getNameroot() {
      return nameroot;
    }


    /**
      * Sets the value of the 'nameroot' field.
      * The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @param value The value of 'nameroot'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setNameroot(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.nameroot = value;
      fieldSetFlags()[5] = true;
      return this;
    }

    /**
      * Checks whether the 'nameroot' field has been set.
      * The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @return True if the 'nameroot' field has been set, false otherwise.
      */
    public boolean hasNameroot() {
      return fieldSetFlags()[5];
    }


    /**
      * Clears the value of the 'nameroot' field.
      * The basename root such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  For the purposess of path splitting leading periods on the
basename are ignored; a basename of `.cshrc` will have a nameroot of
`.cshrc`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearNameroot() {
      nameroot = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /**
      * Gets the value of the 'nameext' field.
      * The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @return The value.
      */
    public java.lang.CharSequence getNameext() {
      return nameext;
    }


    /**
      * Sets the value of the 'nameext' field.
      * The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @param value The value of 'nameext'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setNameext(java.lang.CharSequence value) {
      validate(fields()[6], value);
      this.nameext = value;
      fieldSetFlags()[6] = true;
      return this;
    }

    /**
      * Checks whether the 'nameext' field has been set.
      * The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @return True if the 'nameext' field has been set, false otherwise.
      */
    public boolean hasNameext() {
      return fieldSetFlags()[6];
    }


    /**
      * Clears the value of the 'nameext' field.
      * The basename extension such that `nameroot + nameext == basename`, and
`nameext` is empty or begins with a period and contains at most one
period.  Leading periods on the basename are ignored; a basename of
`.cshrc` will have an empty `nameext`.

The implementation must set this field automatically based on the value
of `basename` prior to evaluating parameter references or expressions.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearNameext() {
      nameext = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /**
      * Gets the value of the 'checksum' field.
      * Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.

      * @return The value.
      */
    public java.lang.CharSequence getChecksum() {
      return checksum;
    }


    /**
      * Sets the value of the 'checksum' field.
      * Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.

      * @param value The value of 'checksum'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setChecksum(java.lang.CharSequence value) {
      validate(fields()[7], value);
      this.checksum = value;
      fieldSetFlags()[7] = true;
      return this;
    }

    /**
      * Checks whether the 'checksum' field has been set.
      * Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.

      * @return True if the 'checksum' field has been set, false otherwise.
      */
    public boolean hasChecksum() {
      return fieldSetFlags()[7];
    }


    /**
      * Clears the value of the 'checksum' field.
      * Optional hash code for validating file integrity.  Currently must be in the form
"sha1$ + hexadecimal string" using the SHA-1 algorithm.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearChecksum() {
      checksum = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /**
      * Gets the value of the 'size' field.
      * Optional file size
      * @return The value.
      */
    public java.lang.Long getSize() {
      return size;
    }


    /**
      * Sets the value of the 'size' field.
      * Optional file size
      * @param value The value of 'size'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setSize(java.lang.Long value) {
      validate(fields()[8], value);
      this.size = value;
      fieldSetFlags()[8] = true;
      return this;
    }

    /**
      * Checks whether the 'size' field has been set.
      * Optional file size
      * @return True if the 'size' field has been set, false otherwise.
      */
    public boolean hasSize() {
      return fieldSetFlags()[8];
    }


    /**
      * Clears the value of the 'size' field.
      * Optional file size
      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearSize() {
      size = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /**
      * Gets the value of the 'secondaryFiles' field.
      * A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.

      * @return The value.
      */
    public java.util.List<java.lang.Object> getSecondaryFiles() {
      return secondaryFiles;
    }


    /**
      * Sets the value of the 'secondaryFiles' field.
      * A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.

      * @param value The value of 'secondaryFiles'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setSecondaryFiles(java.util.List<java.lang.Object> value) {
      validate(fields()[9], value);
      this.secondaryFiles = value;
      fieldSetFlags()[9] = true;
      return this;
    }

    /**
      * Checks whether the 'secondaryFiles' field has been set.
      * A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.

      * @return True if the 'secondaryFiles' field has been set, false otherwise.
      */
    public boolean hasSecondaryFiles() {
      return fieldSetFlags()[9];
    }


    /**
      * Clears the value of the 'secondaryFiles' field.
      * A list of additional files or directories that are associated with the
primary file and must be transferred alongside the primary file.
Examples include indexes of the primary file, or external references
which must be included when loading primary document.  A file object
listed in `secondaryFiles` may itself include `secondaryFiles` for
which the same rules apply.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearSecondaryFiles() {
      secondaryFiles = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /**
      * Gets the value of the 'format' field.
      * The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.

      * @return The value.
      */
    public java.lang.CharSequence getFormat() {
      return format;
    }


    /**
      * Sets the value of the 'format' field.
      * The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.

      * @param value The value of 'format'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setFormat(java.lang.CharSequence value) {
      validate(fields()[10], value);
      this.format = value;
      fieldSetFlags()[10] = true;
      return this;
    }

    /**
      * Checks whether the 'format' field has been set.
      * The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.

      * @return True if the 'format' field has been set, false otherwise.
      */
    public boolean hasFormat() {
      return fieldSetFlags()[10];
    }


    /**
      * Clears the value of the 'format' field.
      * The format of the file: this must be an IRI of a concept node that
represents the file format, preferrably defined within an ontology.
If no ontology is available, file formats may be tested by exact match.

Reasoning about format compatability must be done by checking that an
input file format is the same, `owl:equivalentClass` or
`rdfs:subClassOf` the format required by the input parameter.
`owl:equivalentClass` is transitive with `rdfs:subClassOf`, e.g. if
`B owl:equivalentClass C` and `B owl:subclassOf A` then infer
`C owl:subclassOf A`.

File format ontologies may be provided in the "$schemas" metadata at the
root of the document.  If no ontologies are specified in `$schemas`, the
runtime may perform exact file format matches.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearFormat() {
      format = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /**
      * Gets the value of the 'contents' field.
      * File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.

      * @return The value.
      */
    public java.lang.CharSequence getContents() {
      return contents;
    }


    /**
      * Sets the value of the 'contents' field.
      * File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.

      * @param value The value of 'contents'.
      * @return This builder.
      */
    public io.cwl.avro.File.Builder setContents(java.lang.CharSequence value) {
      validate(fields()[11], value);
      this.contents = value;
      fieldSetFlags()[11] = true;
      return this;
    }

    /**
      * Checks whether the 'contents' field has been set.
      * File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.

      * @return True if the 'contents' field has been set, false otherwise.
      */
    public boolean hasContents() {
      return fieldSetFlags()[11];
    }


    /**
      * Clears the value of the 'contents' field.
      * File contents literal.  Maximum of 64 KiB.

If neither `location` nor `path` is provided, `contents` must be
non-null.  The implementation must assign a unique identifier for the
`location` field.  When the file is staged as input to CommandLineTool,
the value of `contents` must be written to a file.

If `loadContents` of `inputBinding` or `outputBinding` is true and
`location` is valid, the implementation must read up to the first 64
KiB of text from the file and place it in the "contents" field.

      * @return This builder.
      */
    public io.cwl.avro.File.Builder clearContents() {
      contents = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public File build() {
      try {
        File record = new File();
        record.class$ = fieldSetFlags()[0] ? this.class$ : (io.cwl.avro.FilePackage.class$.File_class) defaultValue(fields()[0]);
        record.location = fieldSetFlags()[1] ? this.location : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.path = fieldSetFlags()[2] ? this.path : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.basename = fieldSetFlags()[3] ? this.basename : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.dirname = fieldSetFlags()[4] ? this.dirname : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.nameroot = fieldSetFlags()[5] ? this.nameroot : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.nameext = fieldSetFlags()[6] ? this.nameext : (java.lang.CharSequence) defaultValue(fields()[6]);
        record.checksum = fieldSetFlags()[7] ? this.checksum : (java.lang.CharSequence) defaultValue(fields()[7]);
        record.size = fieldSetFlags()[8] ? this.size : (java.lang.Long) defaultValue(fields()[8]);
        record.secondaryFiles = fieldSetFlags()[9] ? this.secondaryFiles : (java.util.List<java.lang.Object>) defaultValue(fields()[9]);
        record.format = fieldSetFlags()[10] ? this.format : (java.lang.CharSequence) defaultValue(fields()[10]);
        record.contents = fieldSetFlags()[11] ? this.contents : (java.lang.CharSequence) defaultValue(fields()[11]);
        return record;
      } catch (org.apache.avro.AvroMissingFieldException e) {
        throw e;
      } catch (java.lang.Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumWriter<File>
    WRITER$ = (org.apache.avro.io.DatumWriter<File>)MODEL$.createDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumReader<File>
    READER$ = (org.apache.avro.io.DatumReader<File>)MODEL$.createDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

}










