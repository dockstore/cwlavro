/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package io.cwl.avro;

import org.apache.avro.generic.GenericArray;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.util.Utf8;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.SchemaStore;

@org.apache.avro.specific.AvroGenerated
public class SoftwarePackage extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 6563819772765853153L;


  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"SoftwarePackage\",\"namespace\":\"io.cwl.avro\",\"fields\":[{\"name\":\"package\",\"type\":\"string\",\"doc\":\"The name of the software to be made available. If the name is\\ncommon, inconsistent, or otherwise ambiguous it should be combined with\\none or more identifiers in the `specs` field.\\n\"},{\"name\":\"version\",\"type\":[\"null\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"The (optional) versions of the software that are known to be\\ncompatible.\\n\"},{\"name\":\"specs\",\"type\":[\"null\",{\"type\":\"array\",\"items\":\"string\"}],\"doc\":\"One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s\\nidentifying resources for installing or enabling the software named in\\nthe `package` field. Implementations may provide resolvers which map\\nthese software identifer IRIs to some configuration action; or they can\\nuse only the name from the `package` field on a best effort basis.\\n\\nFor example, the IRI https://packages.debian.org/bowtie could\\nbe resolved with `apt-get install bowtie`. The IRI\\nhttps://anaconda.org/bioconda/bowtie could be resolved with `conda\\ninstall -c bioconda bowtie`.\\n\\nIRIs can also be system independent and used to map to a specific\\nsoftware installation or selection mechanism.\\nUsing [RRID](https://www.identifiers.org/rrid/) as an example:\\nhttps://identifiers.org/rrid/RRID:SCR_005476\\ncould be fulfilled using the above mentioned Debian or bioconda\\npackage, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),\\nor any other mechanism the platform chooses. IRIs can also be from\\nidentifer sources that are discipline specific yet still system\\nindependent. As an example, the equivalent [ELIXIR Tools and Data\\nService Registry](https://bio.tools) IRI to the previous RRID example is\\nhttps://bio.tools/tool/bowtie2/version/2.2.8.\\nIf supported by a given registry, implementations are encouraged to\\nquery these system independent sofware identifier IRIs directly for\\nlinks to packaging systems.\\n\\nA site specific IRI can be listed as well. For example, an academic\\ncomputing cluster using Environement Modules could list the IRI\\n`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that\\n`module load bowtie-tbb/1.1.2` should be executed to make available\\n`bowtie` version 1.1.2 compiled with the TBB library prior to running\\nthe accompanying Workflow or CommandLineTool. Note that the example IRI\\nis specific to a particular institution and computing environment as\\nthe Environment Modules system does not have a common namespace or\\nstandardized naming convention.\\n\\nThis last example is the least portable and should only be used if\\nmechanisms based off of the `package` field or more generic IRIs are\\nunavailable or unsuitable. While harmless to other sites, site specific\\nsoftware IRIs should be left out of shared CWL descriptions to avoid\\nclutter.\\n\"}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }

  private static final SpecificData MODEL$ = new SpecificData();

  private static final BinaryMessageEncoder<SoftwarePackage> ENCODER =
      new BinaryMessageEncoder<>(MODEL$, SCHEMA$);

  private static final BinaryMessageDecoder<SoftwarePackage> DECODER =
      new BinaryMessageDecoder<>(MODEL$, SCHEMA$);

  /**
   * Return the BinaryMessageEncoder instance used by this class.
   * @return the message encoder used by this class
   */
  public static BinaryMessageEncoder<SoftwarePackage> getEncoder() {
    return ENCODER;
  }

  /**
   * Return the BinaryMessageDecoder instance used by this class.
   * @return the message decoder used by this class
   */
  public static BinaryMessageDecoder<SoftwarePackage> getDecoder() {
    return DECODER;
  }

  /**
   * Create a new BinaryMessageDecoder instance for this class that uses the specified {@link SchemaStore}.
   * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
   * @return a BinaryMessageDecoder instance for this class backed by the given SchemaStore
   */
  public static BinaryMessageDecoder<SoftwarePackage> createDecoder(SchemaStore resolver) {
    return new BinaryMessageDecoder<>(MODEL$, SCHEMA$, resolver);
  }

  /**
   * Serializes this SoftwarePackage to a ByteBuffer.
   * @return a buffer holding the serialized data for this instance
   * @throws java.io.IOException if this instance could not be serialized
   */
  public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
    return ENCODER.encode(this);
  }

  /**
   * Deserializes a SoftwarePackage from a ByteBuffer.
   * @param b a byte buffer holding serialized data for an instance of this class
   * @return a SoftwarePackage instance decoded from the given buffer
   * @throws java.io.IOException if the given bytes could not be deserialized into an instance of this class
   */
  public static SoftwarePackage fromByteBuffer(
      java.nio.ByteBuffer b) throws java.io.IOException {
    return DECODER.decode(b);
  }

  /** The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.
 */
  private java.lang.CharSequence package$;
  /** The (optional) versions of the software that are known to be
compatible.
 */
  private java.util.List<java.lang.CharSequence> version;
  /** One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.
 */
  private java.util.List<java.lang.CharSequence> specs;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public SoftwarePackage() {}

  /**
   * All-args constructor.
   * @param package$ The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.

   * @param version The (optional) versions of the software that are known to be
compatible.

   * @param specs One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.

   */
  public SoftwarePackage(java.lang.CharSequence package$, java.util.List<java.lang.CharSequence> version, java.util.List<java.lang.CharSequence> specs) {
    this.package$ = package$;
    this.version = version;
    this.specs = specs;
  }

  @Override
  public org.apache.avro.specific.SpecificData getSpecificData() { return MODEL$; }

  @Override
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }

  // Used by DatumWriter.  Applications should not call.
  @Override
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return package$;
    case 1: return version;
    case 2: return specs;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  // Used by DatumReader.  Applications should not call.
  @Override
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: package$ = (java.lang.CharSequence)value$; break;
    case 1: version = (java.util.List<java.lang.CharSequence>)value$; break;
    case 2: specs = (java.util.List<java.lang.CharSequence>)value$; break;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  /**
   * Gets the value of the 'package$' field.
   * @return The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.

   */
  public java.lang.CharSequence getPackage$() {
    return package$;
  }


  /**
   * Sets the value of the 'package$' field.
   * The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.

   * @param value the value to set.
   */
  public void setPackage$(java.lang.CharSequence value) {
    this.package$ = value;
  }

  /**
   * Gets the value of the 'version' field.
   * @return The (optional) versions of the software that are known to be
compatible.

   */
  public java.util.List<java.lang.CharSequence> getVersion() {
    return version;
  }


  /**
   * Sets the value of the 'version' field.
   * The (optional) versions of the software that are known to be
compatible.

   * @param value the value to set.
   */
  public void setVersion(java.util.List<java.lang.CharSequence> value) {
    this.version = value;
  }

  /**
   * Gets the value of the 'specs' field.
   * @return One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.

   */
  public java.util.List<java.lang.CharSequence> getSpecs() {
    return specs;
  }


  /**
   * Sets the value of the 'specs' field.
   * One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.

   * @param value the value to set.
   */
  public void setSpecs(java.util.List<java.lang.CharSequence> value) {
    this.specs = value;
  }

  /**
   * Creates a new SoftwarePackage RecordBuilder.
   * @return A new SoftwarePackage RecordBuilder
   */
  public static io.cwl.avro.SoftwarePackage.Builder newBuilder() {
    return new io.cwl.avro.SoftwarePackage.Builder();
  }

  /**
   * Creates a new SoftwarePackage RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new SoftwarePackage RecordBuilder
   */
  public static io.cwl.avro.SoftwarePackage.Builder newBuilder(io.cwl.avro.SoftwarePackage.Builder other) {
    if (other == null) {
      return new io.cwl.avro.SoftwarePackage.Builder();
    } else {
      return new io.cwl.avro.SoftwarePackage.Builder(other);
    }
  }

  /**
   * Creates a new SoftwarePackage RecordBuilder by copying an existing SoftwarePackage instance.
   * @param other The existing instance to copy.
   * @return A new SoftwarePackage RecordBuilder
   */
  public static io.cwl.avro.SoftwarePackage.Builder newBuilder(io.cwl.avro.SoftwarePackage other) {
    if (other == null) {
      return new io.cwl.avro.SoftwarePackage.Builder();
    } else {
      return new io.cwl.avro.SoftwarePackage.Builder(other);
    }
  }

  /**
   * RecordBuilder for SoftwarePackage instances.
   */
  @org.apache.avro.specific.AvroGenerated
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<SoftwarePackage>
    implements org.apache.avro.data.RecordBuilder<SoftwarePackage> {

    /** The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.
 */
    private java.lang.CharSequence package$;
    /** The (optional) versions of the software that are known to be
compatible.
 */
    private java.util.List<java.lang.CharSequence> version;
    /** One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.
 */
    private java.util.List<java.lang.CharSequence> specs;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$, MODEL$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(io.cwl.avro.SoftwarePackage.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.package$)) {
        this.package$ = data().deepCopy(fields()[0].schema(), other.package$);
        fieldSetFlags()[0] = other.fieldSetFlags()[0];
      }
      if (isValidValue(fields()[1], other.version)) {
        this.version = data().deepCopy(fields()[1].schema(), other.version);
        fieldSetFlags()[1] = other.fieldSetFlags()[1];
      }
      if (isValidValue(fields()[2], other.specs)) {
        this.specs = data().deepCopy(fields()[2].schema(), other.specs);
        fieldSetFlags()[2] = other.fieldSetFlags()[2];
      }
    }

    /**
     * Creates a Builder by copying an existing SoftwarePackage instance
     * @param other The existing instance to copy.
     */
    private Builder(io.cwl.avro.SoftwarePackage other) {
      super(SCHEMA$, MODEL$);
      if (isValidValue(fields()[0], other.package$)) {
        this.package$ = data().deepCopy(fields()[0].schema(), other.package$);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.version)) {
        this.version = data().deepCopy(fields()[1].schema(), other.version);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.specs)) {
        this.specs = data().deepCopy(fields()[2].schema(), other.specs);
        fieldSetFlags()[2] = true;
      }
    }

    /**
      * Gets the value of the 'package$' field.
      * The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.

      * @return The value.
      */
    public java.lang.CharSequence getPackage$() {
      return package$;
    }


    /**
      * Sets the value of the 'package$' field.
      * The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.

      * @param value The value of 'package$'.
      * @return This builder.
      */
    public io.cwl.avro.SoftwarePackage.Builder setPackage$(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.package$ = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'package$' field has been set.
      * The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.

      * @return True if the 'package$' field has been set, false otherwise.
      */
    public boolean hasPackage$() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'package$' field.
      * The name of the software to be made available. If the name is
common, inconsistent, or otherwise ambiguous it should be combined with
one or more identifiers in the `specs` field.

      * @return This builder.
      */
    public io.cwl.avro.SoftwarePackage.Builder clearPackage$() {
      package$ = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'version' field.
      * The (optional) versions of the software that are known to be
compatible.

      * @return The value.
      */
    public java.util.List<java.lang.CharSequence> getVersion() {
      return version;
    }


    /**
      * Sets the value of the 'version' field.
      * The (optional) versions of the software that are known to be
compatible.

      * @param value The value of 'version'.
      * @return This builder.
      */
    public io.cwl.avro.SoftwarePackage.Builder setVersion(java.util.List<java.lang.CharSequence> value) {
      validate(fields()[1], value);
      this.version = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'version' field has been set.
      * The (optional) versions of the software that are known to be
compatible.

      * @return True if the 'version' field has been set, false otherwise.
      */
    public boolean hasVersion() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'version' field.
      * The (optional) versions of the software that are known to be
compatible.

      * @return This builder.
      */
    public io.cwl.avro.SoftwarePackage.Builder clearVersion() {
      version = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'specs' field.
      * One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.

      * @return The value.
      */
    public java.util.List<java.lang.CharSequence> getSpecs() {
      return specs;
    }


    /**
      * Sets the value of the 'specs' field.
      * One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.

      * @param value The value of 'specs'.
      * @return This builder.
      */
    public io.cwl.avro.SoftwarePackage.Builder setSpecs(java.util.List<java.lang.CharSequence> value) {
      validate(fields()[2], value);
      this.specs = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'specs' field has been set.
      * One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.

      * @return True if the 'specs' field has been set, false otherwise.
      */
    public boolean hasSpecs() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'specs' field.
      * One or more [IRI](https://en.wikipedia.org/wiki/Internationalized_Resource_Identifier)s
identifying resources for installing or enabling the software named in
the `package` field. Implementations may provide resolvers which map
these software identifer IRIs to some configuration action; or they can
use only the name from the `package` field on a best effort basis.

For example, the IRI https://packages.debian.org/bowtie could
be resolved with `apt-get install bowtie`. The IRI
https://anaconda.org/bioconda/bowtie could be resolved with `conda
install -c bioconda bowtie`.

IRIs can also be system independent and used to map to a specific
software installation or selection mechanism.
Using [RRID](https://www.identifiers.org/rrid/) as an example:
https://identifiers.org/rrid/RRID:SCR_005476
could be fulfilled using the above mentioned Debian or bioconda
package, a local installation managed by [Environement Modules](http://modules.sourceforge.net/),
or any other mechanism the platform chooses. IRIs can also be from
identifer sources that are discipline specific yet still system
independent. As an example, the equivalent [ELIXIR Tools and Data
Service Registry](https://bio.tools) IRI to the previous RRID example is
https://bio.tools/tool/bowtie2/version/2.2.8.
If supported by a given registry, implementations are encouraged to
query these system independent sofware identifier IRIs directly for
links to packaging systems.

A site specific IRI can be listed as well. For example, an academic
computing cluster using Environement Modules could list the IRI
`https://hpc.example.edu/modules/bowtie-tbb/1.22` to indicate that
`module load bowtie-tbb/1.1.2` should be executed to make available
`bowtie` version 1.1.2 compiled with the TBB library prior to running
the accompanying Workflow or CommandLineTool. Note that the example IRI
is specific to a particular institution and computing environment as
the Environment Modules system does not have a common namespace or
standardized naming convention.

This last example is the least portable and should only be used if
mechanisms based off of the `package` field or more generic IRIs are
unavailable or unsuitable. While harmless to other sites, site specific
software IRIs should be left out of shared CWL descriptions to avoid
clutter.

      * @return This builder.
      */
    public io.cwl.avro.SoftwarePackage.Builder clearSpecs() {
      specs = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public SoftwarePackage build() {
      try {
        SoftwarePackage record = new SoftwarePackage();
        record.package$ = fieldSetFlags()[0] ? this.package$ : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.version = fieldSetFlags()[1] ? this.version : (java.util.List<java.lang.CharSequence>) defaultValue(fields()[1]);
        record.specs = fieldSetFlags()[2] ? this.specs : (java.util.List<java.lang.CharSequence>) defaultValue(fields()[2]);
        return record;
      } catch (org.apache.avro.AvroMissingFieldException e) {
        throw e;
      } catch (java.lang.Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumWriter<SoftwarePackage>
    WRITER$ = (org.apache.avro.io.DatumWriter<SoftwarePackage>)MODEL$.createDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumReader<SoftwarePackage>
    READER$ = (org.apache.avro.io.DatumReader<SoftwarePackage>)MODEL$.createDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

  @Override protected boolean hasCustomCoders() { return true; }

  @Override public void customEncode(org.apache.avro.io.Encoder out)
    throws java.io.IOException
  {
    out.writeString(this.package$);

    if (this.version == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      long size0 = this.version.size();
      out.writeArrayStart();
      out.setItemCount(size0);
      long actualSize0 = 0;
      for (java.lang.CharSequence e0: this.version) {
        actualSize0++;
        out.startItem();
        out.writeString(e0);
      }
      out.writeArrayEnd();
      if (actualSize0 != size0)
        throw new java.util.ConcurrentModificationException("Array-size written was " + size0 + ", but element count was " + actualSize0 + ".");
    }

    if (this.specs == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      long size1 = this.specs.size();
      out.writeArrayStart();
      out.setItemCount(size1);
      long actualSize1 = 0;
      for (java.lang.CharSequence e1: this.specs) {
        actualSize1++;
        out.startItem();
        out.writeString(e1);
      }
      out.writeArrayEnd();
      if (actualSize1 != size1)
        throw new java.util.ConcurrentModificationException("Array-size written was " + size1 + ", but element count was " + actualSize1 + ".");
    }

  }

  @Override public void customDecode(org.apache.avro.io.ResolvingDecoder in)
    throws java.io.IOException
  {
    org.apache.avro.Schema.Field[] fieldOrder = in.readFieldOrderIfDiff();
    if (fieldOrder == null) {
      this.package$ = in.readString(this.package$ instanceof Utf8 ? (Utf8)this.package$ : null);

      if (in.readIndex() != 1) {
        in.readNull();
        this.version = null;
      } else {
        long size0 = in.readArrayStart();
        java.util.List<java.lang.CharSequence> a0 = this.version;
        if (a0 == null) {
          a0 = new SpecificData.Array<java.lang.CharSequence>((int)size0, SCHEMA$.getField("version").schema().getTypes().get(1));
          this.version = a0;
        } else a0.clear();
        SpecificData.Array<java.lang.CharSequence> ga0 = (a0 instanceof SpecificData.Array ? (SpecificData.Array<java.lang.CharSequence>)a0 : null);
        for ( ; 0 < size0; size0 = in.arrayNext()) {
          for ( ; size0 != 0; size0--) {
            java.lang.CharSequence e0 = (ga0 != null ? ga0.peek() : null);
            e0 = in.readString(e0 instanceof Utf8 ? (Utf8)e0 : null);
            a0.add(e0);
          }
        }
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.specs = null;
      } else {
        long size1 = in.readArrayStart();
        java.util.List<java.lang.CharSequence> a1 = this.specs;
        if (a1 == null) {
          a1 = new SpecificData.Array<java.lang.CharSequence>((int)size1, SCHEMA$.getField("specs").schema().getTypes().get(1));
          this.specs = a1;
        } else a1.clear();
        SpecificData.Array<java.lang.CharSequence> ga1 = (a1 instanceof SpecificData.Array ? (SpecificData.Array<java.lang.CharSequence>)a1 : null);
        for ( ; 0 < size1; size1 = in.arrayNext()) {
          for ( ; size1 != 0; size1--) {
            java.lang.CharSequence e1 = (ga1 != null ? ga1.peek() : null);
            e1 = in.readString(e1 instanceof Utf8 ? (Utf8)e1 : null);
            a1.add(e1);
          }
        }
      }

    } else {
      for (int i = 0; i < 3; i++) {
        switch (fieldOrder[i].pos()) {
        case 0:
          this.package$ = in.readString(this.package$ instanceof Utf8 ? (Utf8)this.package$ : null);
          break;

        case 1:
          if (in.readIndex() != 1) {
            in.readNull();
            this.version = null;
          } else {
            long size0 = in.readArrayStart();
            java.util.List<java.lang.CharSequence> a0 = this.version;
            if (a0 == null) {
              a0 = new SpecificData.Array<java.lang.CharSequence>((int)size0, SCHEMA$.getField("version").schema().getTypes().get(1));
              this.version = a0;
            } else a0.clear();
            SpecificData.Array<java.lang.CharSequence> ga0 = (a0 instanceof SpecificData.Array ? (SpecificData.Array<java.lang.CharSequence>)a0 : null);
            for ( ; 0 < size0; size0 = in.arrayNext()) {
              for ( ; size0 != 0; size0--) {
                java.lang.CharSequence e0 = (ga0 != null ? ga0.peek() : null);
                e0 = in.readString(e0 instanceof Utf8 ? (Utf8)e0 : null);
                a0.add(e0);
              }
            }
          }
          break;

        case 2:
          if (in.readIndex() != 1) {
            in.readNull();
            this.specs = null;
          } else {
            long size1 = in.readArrayStart();
            java.util.List<java.lang.CharSequence> a1 = this.specs;
            if (a1 == null) {
              a1 = new SpecificData.Array<java.lang.CharSequence>((int)size1, SCHEMA$.getField("specs").schema().getTypes().get(1));
              this.specs = a1;
            } else a1.clear();
            SpecificData.Array<java.lang.CharSequence> ga1 = (a1 instanceof SpecificData.Array ? (SpecificData.Array<java.lang.CharSequence>)a1 : null);
            for ( ; 0 < size1; size1 = in.arrayNext()) {
              for ( ; size1 != 0; size1--) {
                java.lang.CharSequence e1 = (ga1 != null ? ga1.peek() : null);
                e1 = in.readString(e1 instanceof Utf8 ? (Utf8)e1 : null);
                a1.add(e1);
              }
            }
          }
          break;

        default:
          throw new java.io.IOException("Corrupt ResolvingDecoder.");
        }
      }
    }
  }
}










