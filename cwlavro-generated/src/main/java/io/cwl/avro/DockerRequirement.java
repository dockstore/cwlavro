/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package io.cwl.avro;

import org.apache.avro.generic.GenericArray;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.util.Utf8;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.SchemaStore;

/** Indicates that a workflow component should be run in a
[Docker](http://docker.com) container, and specifies how to fetch or build
the image.

If a CommandLineTool lists `DockerRequirement` under
`hints` (or `requirements`), it may (or must) be run in the specified Docker
container.

The platform must first acquire or install the correct Docker image as
specified by `dockerPull`, `dockerImport`, `dockerLoad` or `dockerFile`.

The platform must execute the tool in the container using `docker run` with
the appropriate Docker image and tool command line.

The workflow platform may provide input files and the designated output
directory through the use of volume bind mounts.  The platform should rewrite
file paths in the input object to correspond to the Docker bind mounted
locations. That is, the platform should rewrite values in the parameter context
such as `runtime.outdir`, `runtime.tmpdir` and others to be valid paths
within the container.

When running a tool contained in Docker, the workflow platform must not
assume anything about the contents of the Docker container, such as the
presence or absence of specific software, except to assume that the
generated command line represents a valid command within the runtime
environment of the container.

## Interaction with other requirements

If [EnvVarRequirement](#EnvVarRequirement) is specified alongside a
DockerRequirement, the environment variables must be provided to Docker
using `--env` or `--env-file` and interact with the container's preexisting
environment as defined by Docker.
 */
@org.apache.avro.specific.AvroGenerated
public class DockerRequirement extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 6096552737949539564L;


  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"DockerRequirement\",\"namespace\":\"io.cwl.avro\",\"doc\":\"Indicates that a workflow component should be run in a\\n[Docker](http://docker.com) container, and specifies how to fetch or build\\nthe image.\\n\\nIf a CommandLineTool lists `DockerRequirement` under\\n`hints` (or `requirements`), it may (or must) be run in the specified Docker\\ncontainer.\\n\\nThe platform must first acquire or install the correct Docker image as\\nspecified by `dockerPull`, `dockerImport`, `dockerLoad` or `dockerFile`.\\n\\nThe platform must execute the tool in the container using `docker run` with\\nthe appropriate Docker image and tool command line.\\n\\nThe workflow platform may provide input files and the designated output\\ndirectory through the use of volume bind mounts.  The platform should rewrite\\nfile paths in the input object to correspond to the Docker bind mounted\\nlocations. That is, the platform should rewrite values in the parameter context\\nsuch as `runtime.outdir`, `runtime.tmpdir` and others to be valid paths\\nwithin the container.\\n\\nWhen running a tool contained in Docker, the workflow platform must not\\nassume anything about the contents of the Docker container, such as the\\npresence or absence of specific software, except to assume that the\\ngenerated command line represents a valid command within the runtime\\nenvironment of the container.\\n\\n## Interaction with other requirements\\n\\nIf [EnvVarRequirement](#EnvVarRequirement) is specified alongside a\\nDockerRequirement, the environment variables must be provided to Docker\\nusing `--env` or `--env-file` and interact with the container's preexisting\\nenvironment as defined by Docker.\\n\",\"fields\":[{\"name\":\"class\",\"type\":\"string\",\"doc\":\"Always 'DockerRequirement'\",\"jsonldPredicate\":{\"_id\":\"@type\",\"_type\":\"@vocab\"}},{\"name\":\"dockerPull\",\"type\":[\"null\",\"string\"],\"doc\":\"Specify a Docker image to retrieve using `docker pull`.\"},{\"name\":\"dockerLoad\",\"type\":[\"null\",\"string\"],\"doc\":\"Specify a HTTP URL from which to download a Docker image using `docker load`.\"},{\"name\":\"dockerFile\",\"type\":[\"null\",\"string\"],\"doc\":\"Supply the contents of a Dockerfile which will be built using `docker build`.\"},{\"name\":\"dockerImport\",\"type\":[\"null\",\"string\"],\"doc\":\"Provide HTTP URL to download and gunzip a Docker images using `docker import.\"},{\"name\":\"dockerImageId\",\"type\":[\"null\",\"string\"],\"doc\":\"The image id that will be used for `docker run`.  May be a\\nhuman-readable image name or the image identifier hash.  May be skipped\\nif `dockerPull` is specified, in which case the `dockerPull` image id\\nmust be used.\\n\"},{\"name\":\"dockerOutputDirectory\",\"type\":[\"null\",\"string\"],\"doc\":\"Set the designated output directory to a specific location inside the\\nDocker container.\\n\"}],\"extends\":\"https://w3id.org/cwl/cwl#ProcessRequirement\"}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }

  private static final SpecificData MODEL$ = new SpecificData();

  private static final BinaryMessageEncoder<DockerRequirement> ENCODER =
      new BinaryMessageEncoder<>(MODEL$, SCHEMA$);

  private static final BinaryMessageDecoder<DockerRequirement> DECODER =
      new BinaryMessageDecoder<>(MODEL$, SCHEMA$);

  /**
   * Return the BinaryMessageEncoder instance used by this class.
   * @return the message encoder used by this class
   */
  public static BinaryMessageEncoder<DockerRequirement> getEncoder() {
    return ENCODER;
  }

  /**
   * Return the BinaryMessageDecoder instance used by this class.
   * @return the message decoder used by this class
   */
  public static BinaryMessageDecoder<DockerRequirement> getDecoder() {
    return DECODER;
  }

  /**
   * Create a new BinaryMessageDecoder instance for this class that uses the specified {@link SchemaStore}.
   * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
   * @return a BinaryMessageDecoder instance for this class backed by the given SchemaStore
   */
  public static BinaryMessageDecoder<DockerRequirement> createDecoder(SchemaStore resolver) {
    return new BinaryMessageDecoder<>(MODEL$, SCHEMA$, resolver);
  }

  /**
   * Serializes this DockerRequirement to a ByteBuffer.
   * @return a buffer holding the serialized data for this instance
   * @throws java.io.IOException if this instance could not be serialized
   */
  public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
    return ENCODER.encode(this);
  }

  /**
   * Deserializes a DockerRequirement from a ByteBuffer.
   * @param b a byte buffer holding serialized data for an instance of this class
   * @return a DockerRequirement instance decoded from the given buffer
   * @throws java.io.IOException if the given bytes could not be deserialized into an instance of this class
   */
  public static DockerRequirement fromByteBuffer(
      java.nio.ByteBuffer b) throws java.io.IOException {
    return DECODER.decode(b);
  }

  /** Always 'DockerRequirement' */
  public java.lang.CharSequence class$;
  /** Specify a Docker image to retrieve using `docker pull`. */
  public java.lang.CharSequence dockerPull;
  /** Specify a HTTP URL from which to download a Docker image using `docker load`. */
  public java.lang.CharSequence dockerLoad;
  /** Supply the contents of a Dockerfile which will be built using `docker build`. */
  public java.lang.CharSequence dockerFile;
  /** Provide HTTP URL to download and gunzip a Docker images using `docker import. */
  public java.lang.CharSequence dockerImport;
  /** The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.
 */
  public java.lang.CharSequence dockerImageId;
  /** Set the designated output directory to a specific location inside the
Docker container.
 */
  public java.lang.CharSequence dockerOutputDirectory;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public DockerRequirement() {}

  /**
   * All-args constructor.
   * @param class$ Always 'DockerRequirement'
   * @param dockerPull Specify a Docker image to retrieve using `docker pull`.
   * @param dockerLoad Specify a HTTP URL from which to download a Docker image using `docker load`.
   * @param dockerFile Supply the contents of a Dockerfile which will be built using `docker build`.
   * @param dockerImport Provide HTTP URL to download and gunzip a Docker images using `docker import.
   * @param dockerImageId The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.

   * @param dockerOutputDirectory Set the designated output directory to a specific location inside the
Docker container.

   */
  public DockerRequirement(java.lang.CharSequence class$, java.lang.CharSequence dockerPull, java.lang.CharSequence dockerLoad, java.lang.CharSequence dockerFile, java.lang.CharSequence dockerImport, java.lang.CharSequence dockerImageId, java.lang.CharSequence dockerOutputDirectory) {
    this.class$ = class$;
    this.dockerPull = dockerPull;
    this.dockerLoad = dockerLoad;
    this.dockerFile = dockerFile;
    this.dockerImport = dockerImport;
    this.dockerImageId = dockerImageId;
    this.dockerOutputDirectory = dockerOutputDirectory;
  }

  @Override
  public org.apache.avro.specific.SpecificData getSpecificData() { return MODEL$; }

  @Override
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }

  // Used by DatumWriter.  Applications should not call.
  @Override
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return class$;
    case 1: return dockerPull;
    case 2: return dockerLoad;
    case 3: return dockerFile;
    case 4: return dockerImport;
    case 5: return dockerImageId;
    case 6: return dockerOutputDirectory;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  // Used by DatumReader.  Applications should not call.
  @Override
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: class$ = (java.lang.CharSequence)value$; break;
    case 1: dockerPull = (java.lang.CharSequence)value$; break;
    case 2: dockerLoad = (java.lang.CharSequence)value$; break;
    case 3: dockerFile = (java.lang.CharSequence)value$; break;
    case 4: dockerImport = (java.lang.CharSequence)value$; break;
    case 5: dockerImageId = (java.lang.CharSequence)value$; break;
    case 6: dockerOutputDirectory = (java.lang.CharSequence)value$; break;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  /**
   * Gets the value of the 'class$' field.
   * @return Always 'DockerRequirement'
   */
  public java.lang.CharSequence getClass$() {
    return class$;
  }


  /**
   * Sets the value of the 'class$' field.
   * Always 'DockerRequirement'
   * @param value the value to set.
   */
  public void setClass$(java.lang.CharSequence value) {
    this.class$ = value;
  }

  /**
   * Gets the value of the 'dockerPull' field.
   * @return Specify a Docker image to retrieve using `docker pull`.
   */
  public java.lang.CharSequence getDockerPull() {
    return dockerPull;
  }


  /**
   * Sets the value of the 'dockerPull' field.
   * Specify a Docker image to retrieve using `docker pull`.
   * @param value the value to set.
   */
  public void setDockerPull(java.lang.CharSequence value) {
    this.dockerPull = value;
  }

  /**
   * Gets the value of the 'dockerLoad' field.
   * @return Specify a HTTP URL from which to download a Docker image using `docker load`.
   */
  public java.lang.CharSequence getDockerLoad() {
    return dockerLoad;
  }


  /**
   * Sets the value of the 'dockerLoad' field.
   * Specify a HTTP URL from which to download a Docker image using `docker load`.
   * @param value the value to set.
   */
  public void setDockerLoad(java.lang.CharSequence value) {
    this.dockerLoad = value;
  }

  /**
   * Gets the value of the 'dockerFile' field.
   * @return Supply the contents of a Dockerfile which will be built using `docker build`.
   */
  public java.lang.CharSequence getDockerFile() {
    return dockerFile;
  }


  /**
   * Sets the value of the 'dockerFile' field.
   * Supply the contents of a Dockerfile which will be built using `docker build`.
   * @param value the value to set.
   */
  public void setDockerFile(java.lang.CharSequence value) {
    this.dockerFile = value;
  }

  /**
   * Gets the value of the 'dockerImport' field.
   * @return Provide HTTP URL to download and gunzip a Docker images using `docker import.
   */
  public java.lang.CharSequence getDockerImport() {
    return dockerImport;
  }


  /**
   * Sets the value of the 'dockerImport' field.
   * Provide HTTP URL to download and gunzip a Docker images using `docker import.
   * @param value the value to set.
   */
  public void setDockerImport(java.lang.CharSequence value) {
    this.dockerImport = value;
  }

  /**
   * Gets the value of the 'dockerImageId' field.
   * @return The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.

   */
  public java.lang.CharSequence getDockerImageId() {
    return dockerImageId;
  }


  /**
   * Sets the value of the 'dockerImageId' field.
   * The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.

   * @param value the value to set.
   */
  public void setDockerImageId(java.lang.CharSequence value) {
    this.dockerImageId = value;
  }

  /**
   * Gets the value of the 'dockerOutputDirectory' field.
   * @return Set the designated output directory to a specific location inside the
Docker container.

   */
  public java.lang.CharSequence getDockerOutputDirectory() {
    return dockerOutputDirectory;
  }


  /**
   * Sets the value of the 'dockerOutputDirectory' field.
   * Set the designated output directory to a specific location inside the
Docker container.

   * @param value the value to set.
   */
  public void setDockerOutputDirectory(java.lang.CharSequence value) {
    this.dockerOutputDirectory = value;
  }

  /**
   * Creates a new DockerRequirement RecordBuilder.
   * @return A new DockerRequirement RecordBuilder
   */
  public static io.cwl.avro.DockerRequirement.Builder newBuilder() {
    return new io.cwl.avro.DockerRequirement.Builder();
  }

  /**
   * Creates a new DockerRequirement RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new DockerRequirement RecordBuilder
   */
  public static io.cwl.avro.DockerRequirement.Builder newBuilder(io.cwl.avro.DockerRequirement.Builder other) {
    if (other == null) {
      return new io.cwl.avro.DockerRequirement.Builder();
    } else {
      return new io.cwl.avro.DockerRequirement.Builder(other);
    }
  }

  /**
   * Creates a new DockerRequirement RecordBuilder by copying an existing DockerRequirement instance.
   * @param other The existing instance to copy.
   * @return A new DockerRequirement RecordBuilder
   */
  public static io.cwl.avro.DockerRequirement.Builder newBuilder(io.cwl.avro.DockerRequirement other) {
    if (other == null) {
      return new io.cwl.avro.DockerRequirement.Builder();
    } else {
      return new io.cwl.avro.DockerRequirement.Builder(other);
    }
  }

  /**
   * RecordBuilder for DockerRequirement instances.
   */
  @org.apache.avro.specific.AvroGenerated
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<DockerRequirement>
    implements org.apache.avro.data.RecordBuilder<DockerRequirement> {

    /** Always 'DockerRequirement' */
    private java.lang.CharSequence class$;
    /** Specify a Docker image to retrieve using `docker pull`. */
    private java.lang.CharSequence dockerPull;
    /** Specify a HTTP URL from which to download a Docker image using `docker load`. */
    private java.lang.CharSequence dockerLoad;
    /** Supply the contents of a Dockerfile which will be built using `docker build`. */
    private java.lang.CharSequence dockerFile;
    /** Provide HTTP URL to download and gunzip a Docker images using `docker import. */
    private java.lang.CharSequence dockerImport;
    /** The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.
 */
    private java.lang.CharSequence dockerImageId;
    /** Set the designated output directory to a specific location inside the
Docker container.
 */
    private java.lang.CharSequence dockerOutputDirectory;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$, MODEL$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(io.cwl.avro.DockerRequirement.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.class$)) {
        this.class$ = data().deepCopy(fields()[0].schema(), other.class$);
        fieldSetFlags()[0] = other.fieldSetFlags()[0];
      }
      if (isValidValue(fields()[1], other.dockerPull)) {
        this.dockerPull = data().deepCopy(fields()[1].schema(), other.dockerPull);
        fieldSetFlags()[1] = other.fieldSetFlags()[1];
      }
      if (isValidValue(fields()[2], other.dockerLoad)) {
        this.dockerLoad = data().deepCopy(fields()[2].schema(), other.dockerLoad);
        fieldSetFlags()[2] = other.fieldSetFlags()[2];
      }
      if (isValidValue(fields()[3], other.dockerFile)) {
        this.dockerFile = data().deepCopy(fields()[3].schema(), other.dockerFile);
        fieldSetFlags()[3] = other.fieldSetFlags()[3];
      }
      if (isValidValue(fields()[4], other.dockerImport)) {
        this.dockerImport = data().deepCopy(fields()[4].schema(), other.dockerImport);
        fieldSetFlags()[4] = other.fieldSetFlags()[4];
      }
      if (isValidValue(fields()[5], other.dockerImageId)) {
        this.dockerImageId = data().deepCopy(fields()[5].schema(), other.dockerImageId);
        fieldSetFlags()[5] = other.fieldSetFlags()[5];
      }
      if (isValidValue(fields()[6], other.dockerOutputDirectory)) {
        this.dockerOutputDirectory = data().deepCopy(fields()[6].schema(), other.dockerOutputDirectory);
        fieldSetFlags()[6] = other.fieldSetFlags()[6];
      }
    }

    /**
     * Creates a Builder by copying an existing DockerRequirement instance
     * @param other The existing instance to copy.
     */
    private Builder(io.cwl.avro.DockerRequirement other) {
      super(SCHEMA$, MODEL$);
      if (isValidValue(fields()[0], other.class$)) {
        this.class$ = data().deepCopy(fields()[0].schema(), other.class$);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.dockerPull)) {
        this.dockerPull = data().deepCopy(fields()[1].schema(), other.dockerPull);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.dockerLoad)) {
        this.dockerLoad = data().deepCopy(fields()[2].schema(), other.dockerLoad);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.dockerFile)) {
        this.dockerFile = data().deepCopy(fields()[3].schema(), other.dockerFile);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.dockerImport)) {
        this.dockerImport = data().deepCopy(fields()[4].schema(), other.dockerImport);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.dockerImageId)) {
        this.dockerImageId = data().deepCopy(fields()[5].schema(), other.dockerImageId);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.dockerOutputDirectory)) {
        this.dockerOutputDirectory = data().deepCopy(fields()[6].schema(), other.dockerOutputDirectory);
        fieldSetFlags()[6] = true;
      }
    }

    /**
      * Gets the value of the 'class$' field.
      * Always 'DockerRequirement'
      * @return The value.
      */
    public java.lang.CharSequence getClass$() {
      return class$;
    }


    /**
      * Sets the value of the 'class$' field.
      * Always 'DockerRequirement'
      * @param value The value of 'class$'.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder setClass$(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.class$ = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'class$' field has been set.
      * Always 'DockerRequirement'
      * @return True if the 'class$' field has been set, false otherwise.
      */
    public boolean hasClass$() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'class$' field.
      * Always 'DockerRequirement'
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder clearClass$() {
      class$ = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'dockerPull' field.
      * Specify a Docker image to retrieve using `docker pull`.
      * @return The value.
      */
    public java.lang.CharSequence getDockerPull() {
      return dockerPull;
    }


    /**
      * Sets the value of the 'dockerPull' field.
      * Specify a Docker image to retrieve using `docker pull`.
      * @param value The value of 'dockerPull'.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder setDockerPull(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.dockerPull = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'dockerPull' field has been set.
      * Specify a Docker image to retrieve using `docker pull`.
      * @return True if the 'dockerPull' field has been set, false otherwise.
      */
    public boolean hasDockerPull() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'dockerPull' field.
      * Specify a Docker image to retrieve using `docker pull`.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder clearDockerPull() {
      dockerPull = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'dockerLoad' field.
      * Specify a HTTP URL from which to download a Docker image using `docker load`.
      * @return The value.
      */
    public java.lang.CharSequence getDockerLoad() {
      return dockerLoad;
    }


    /**
      * Sets the value of the 'dockerLoad' field.
      * Specify a HTTP URL from which to download a Docker image using `docker load`.
      * @param value The value of 'dockerLoad'.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder setDockerLoad(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.dockerLoad = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'dockerLoad' field has been set.
      * Specify a HTTP URL from which to download a Docker image using `docker load`.
      * @return True if the 'dockerLoad' field has been set, false otherwise.
      */
    public boolean hasDockerLoad() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'dockerLoad' field.
      * Specify a HTTP URL from which to download a Docker image using `docker load`.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder clearDockerLoad() {
      dockerLoad = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'dockerFile' field.
      * Supply the contents of a Dockerfile which will be built using `docker build`.
      * @return The value.
      */
    public java.lang.CharSequence getDockerFile() {
      return dockerFile;
    }


    /**
      * Sets the value of the 'dockerFile' field.
      * Supply the contents of a Dockerfile which will be built using `docker build`.
      * @param value The value of 'dockerFile'.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder setDockerFile(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.dockerFile = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'dockerFile' field has been set.
      * Supply the contents of a Dockerfile which will be built using `docker build`.
      * @return True if the 'dockerFile' field has been set, false otherwise.
      */
    public boolean hasDockerFile() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'dockerFile' field.
      * Supply the contents of a Dockerfile which will be built using `docker build`.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder clearDockerFile() {
      dockerFile = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'dockerImport' field.
      * Provide HTTP URL to download and gunzip a Docker images using `docker import.
      * @return The value.
      */
    public java.lang.CharSequence getDockerImport() {
      return dockerImport;
    }


    /**
      * Sets the value of the 'dockerImport' field.
      * Provide HTTP URL to download and gunzip a Docker images using `docker import.
      * @param value The value of 'dockerImport'.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder setDockerImport(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.dockerImport = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'dockerImport' field has been set.
      * Provide HTTP URL to download and gunzip a Docker images using `docker import.
      * @return True if the 'dockerImport' field has been set, false otherwise.
      */
    public boolean hasDockerImport() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'dockerImport' field.
      * Provide HTTP URL to download and gunzip a Docker images using `docker import.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder clearDockerImport() {
      dockerImport = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /**
      * Gets the value of the 'dockerImageId' field.
      * The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.

      * @return The value.
      */
    public java.lang.CharSequence getDockerImageId() {
      return dockerImageId;
    }


    /**
      * Sets the value of the 'dockerImageId' field.
      * The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.

      * @param value The value of 'dockerImageId'.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder setDockerImageId(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.dockerImageId = value;
      fieldSetFlags()[5] = true;
      return this;
    }

    /**
      * Checks whether the 'dockerImageId' field has been set.
      * The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.

      * @return True if the 'dockerImageId' field has been set, false otherwise.
      */
    public boolean hasDockerImageId() {
      return fieldSetFlags()[5];
    }


    /**
      * Clears the value of the 'dockerImageId' field.
      * The image id that will be used for `docker run`.  May be a
human-readable image name or the image identifier hash.  May be skipped
if `dockerPull` is specified, in which case the `dockerPull` image id
must be used.

      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder clearDockerImageId() {
      dockerImageId = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /**
      * Gets the value of the 'dockerOutputDirectory' field.
      * Set the designated output directory to a specific location inside the
Docker container.

      * @return The value.
      */
    public java.lang.CharSequence getDockerOutputDirectory() {
      return dockerOutputDirectory;
    }


    /**
      * Sets the value of the 'dockerOutputDirectory' field.
      * Set the designated output directory to a specific location inside the
Docker container.

      * @param value The value of 'dockerOutputDirectory'.
      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder setDockerOutputDirectory(java.lang.CharSequence value) {
      validate(fields()[6], value);
      this.dockerOutputDirectory = value;
      fieldSetFlags()[6] = true;
      return this;
    }

    /**
      * Checks whether the 'dockerOutputDirectory' field has been set.
      * Set the designated output directory to a specific location inside the
Docker container.

      * @return True if the 'dockerOutputDirectory' field has been set, false otherwise.
      */
    public boolean hasDockerOutputDirectory() {
      return fieldSetFlags()[6];
    }


    /**
      * Clears the value of the 'dockerOutputDirectory' field.
      * Set the designated output directory to a specific location inside the
Docker container.

      * @return This builder.
      */
    public io.cwl.avro.DockerRequirement.Builder clearDockerOutputDirectory() {
      dockerOutputDirectory = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public DockerRequirement build() {
      try {
        DockerRequirement record = new DockerRequirement();
        record.class$ = fieldSetFlags()[0] ? this.class$ : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.dockerPull = fieldSetFlags()[1] ? this.dockerPull : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.dockerLoad = fieldSetFlags()[2] ? this.dockerLoad : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.dockerFile = fieldSetFlags()[3] ? this.dockerFile : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.dockerImport = fieldSetFlags()[4] ? this.dockerImport : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.dockerImageId = fieldSetFlags()[5] ? this.dockerImageId : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.dockerOutputDirectory = fieldSetFlags()[6] ? this.dockerOutputDirectory : (java.lang.CharSequence) defaultValue(fields()[6]);
        return record;
      } catch (org.apache.avro.AvroMissingFieldException e) {
        throw e;
      } catch (java.lang.Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumWriter<DockerRequirement>
    WRITER$ = (org.apache.avro.io.DatumWriter<DockerRequirement>)MODEL$.createDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumReader<DockerRequirement>
    READER$ = (org.apache.avro.io.DatumReader<DockerRequirement>)MODEL$.createDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

  @Override protected boolean hasCustomCoders() { return true; }

  @Override public void customEncode(org.apache.avro.io.Encoder out)
    throws java.io.IOException
  {
    out.writeString(this.class$);

    if (this.dockerPull == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.dockerPull);
    }

    if (this.dockerLoad == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.dockerLoad);
    }

    if (this.dockerFile == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.dockerFile);
    }

    if (this.dockerImport == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.dockerImport);
    }

    if (this.dockerImageId == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.dockerImageId);
    }

    if (this.dockerOutputDirectory == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.dockerOutputDirectory);
    }

  }

  @Override public void customDecode(org.apache.avro.io.ResolvingDecoder in)
    throws java.io.IOException
  {
    org.apache.avro.Schema.Field[] fieldOrder = in.readFieldOrderIfDiff();
    if (fieldOrder == null) {
      this.class$ = in.readString(this.class$ instanceof Utf8 ? (Utf8)this.class$ : null);

      if (in.readIndex() != 1) {
        in.readNull();
        this.dockerPull = null;
      } else {
        this.dockerPull = in.readString(this.dockerPull instanceof Utf8 ? (Utf8)this.dockerPull : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.dockerLoad = null;
      } else {
        this.dockerLoad = in.readString(this.dockerLoad instanceof Utf8 ? (Utf8)this.dockerLoad : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.dockerFile = null;
      } else {
        this.dockerFile = in.readString(this.dockerFile instanceof Utf8 ? (Utf8)this.dockerFile : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.dockerImport = null;
      } else {
        this.dockerImport = in.readString(this.dockerImport instanceof Utf8 ? (Utf8)this.dockerImport : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.dockerImageId = null;
      } else {
        this.dockerImageId = in.readString(this.dockerImageId instanceof Utf8 ? (Utf8)this.dockerImageId : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.dockerOutputDirectory = null;
      } else {
        this.dockerOutputDirectory = in.readString(this.dockerOutputDirectory instanceof Utf8 ? (Utf8)this.dockerOutputDirectory : null);
      }

    } else {
      for (int i = 0; i < 7; i++) {
        switch (fieldOrder[i].pos()) {
        case 0:
          this.class$ = in.readString(this.class$ instanceof Utf8 ? (Utf8)this.class$ : null);
          break;

        case 1:
          if (in.readIndex() != 1) {
            in.readNull();
            this.dockerPull = null;
          } else {
            this.dockerPull = in.readString(this.dockerPull instanceof Utf8 ? (Utf8)this.dockerPull : null);
          }
          break;

        case 2:
          if (in.readIndex() != 1) {
            in.readNull();
            this.dockerLoad = null;
          } else {
            this.dockerLoad = in.readString(this.dockerLoad instanceof Utf8 ? (Utf8)this.dockerLoad : null);
          }
          break;

        case 3:
          if (in.readIndex() != 1) {
            in.readNull();
            this.dockerFile = null;
          } else {
            this.dockerFile = in.readString(this.dockerFile instanceof Utf8 ? (Utf8)this.dockerFile : null);
          }
          break;

        case 4:
          if (in.readIndex() != 1) {
            in.readNull();
            this.dockerImport = null;
          } else {
            this.dockerImport = in.readString(this.dockerImport instanceof Utf8 ? (Utf8)this.dockerImport : null);
          }
          break;

        case 5:
          if (in.readIndex() != 1) {
            in.readNull();
            this.dockerImageId = null;
          } else {
            this.dockerImageId = in.readString(this.dockerImageId instanceof Utf8 ? (Utf8)this.dockerImageId : null);
          }
          break;

        case 6:
          if (in.readIndex() != 1) {
            in.readNull();
            this.dockerOutputDirectory = null;
          } else {
            this.dockerOutputDirectory = in.readString(this.dockerOutputDirectory instanceof Utf8 ? (Utf8)this.dockerOutputDirectory : null);
          }
          break;

        default:
          throw new java.io.IOException("Corrupt ResolvingDecoder.");
        }
      }
    }
  }
}










